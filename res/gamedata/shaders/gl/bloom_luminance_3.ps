#include "common.h"
#include "iostructs\p_filter.h"

//////////////////////////////////////////////////////////////////////////////////////////
uniform float4	MiddleGray;
//////////////////////////////////////////////////////////////////////////////////////////
//	perform 4x4 bilinear, 8x8p, the step (C)
//	c):	8x8p	=> 1x1p		with exp

	// native bilinear
float sampleTex( float2 tc )
{
	float4	data = tex2D(s_image,tc);
	return 	dot( data, float4(1.0/4.0) );	// sum components
}

float4 _main ( p_filter I )
{
	// sample
	float4 	accum0;
		accum0.x =	sampleTex(I.Tex0.xy);
		accum0.y = 	sampleTex(I.Tex1.xy);
		accum0.z = 	sampleTex(I.Tex2.xy);
		accum0.w =	sampleTex(I.Tex3.xy);
	float4 	accum1;
		accum1.x =	sampleTex(I.Tex4.xy);
		accum1.y = 	sampleTex(I.Tex5.xy);
		accum1.z = 	sampleTex(I.Tex6.xy);
		accum1.w =	sampleTex(I.Tex7.xy);
	float4 	accum2;
		accum2.x =	sampleTex(I.Tex0.wz);
		accum2.y = 	sampleTex(I.Tex1.wz);
		accum2.z = 	sampleTex(I.Tex2.wz);
		accum2.w =	sampleTex(I.Tex3.wz);
	float4 	accum3;
		accum3.x =	sampleTex(I.Tex4.wz);
		accum3.y = 	sampleTex(I.Tex5.wz);
		accum3.z = 	sampleTex(I.Tex6.wz);
		accum3.w =	sampleTex(I.Tex7.wz);

	// perform accumulation
	float4	final;
		final.x	= dot(accum0,float4(1.0/4.0));
		final.y	= dot(accum1,float4(1.0/4.0));
		final.z	= dot(accum2,float4(1.0/4.0));
		final.w	= dot(accum3,float4(1.0/4.0));
	float 	result	= dot(final, float4(1.0/4.0));

	// OK
	float	scale 		= MiddleGray.x / (result*MiddleGray.y + MiddleGray.z);	// final
	float  	scale_prev	= tex2D	(s_tonemap,I.Tex0.xy).x;
	float 	rvalue		= lerp	(scale_prev,scale,MiddleGray.w);

//			clamp		(rvalue, 1.0/8.0, 2.0);

			clamp		(rvalue, 1.0/128.0, 20.0);

	return 	float4(rvalue)		;

}
