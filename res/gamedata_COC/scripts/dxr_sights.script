--------------------------------
----- Written by Darryl123 -----
--------------------------------

-------------------------
----- Miscellaneous -----
-------------------------

-- Table of all items to consider as sights.
local sights_table = alun_utils.collect_sections(system_ini(), {"wpn_addon_sight_table"})

-- Determines whether a sight is valid.
local function check_sight(sight_sect, weapon_sect)
	local valid_sights = alun_utils.parse_list(system_ini(), weapon_sect, "sights")
	for k, v in pairs(valid_sights) do
		if (v == sight_sect) then
			return true
		end
	end
	return false
end

-- Determines which weapon is to be modified.
function get_weapon(slot)
	local item = nil
	slot = slot or db.actor:active_slot()
	
	if (slot == 3 or slot == 2) then
		item = db.actor:item_in_slot(slot)
		if (item and IsWeapon(item)) then 
			return item
		end
	end
	
	item = db.actor:item_in_slot(3)
	if (item and IsWeapon(item)) then 
		return item 
	end
	
	item = db.actor:item_in_slot(2)
	if (item and IsWeapon(item)) then 
		return item 
	end
end

-- Initialises callbacks and other dependencies.
function on_game_start()
	-- Only fire if the "wpn_addon_sight_table" section exists.
	-- This will only be true if a sight requiring this script is installed.
	if (system_ini():section_exist("wpn_addon_sight_table")) then
		local console = get_console()
		local snd_targets = console:get_float("snd_targets")
		if (snd_targets < 1000) then
			console:execute("snd_targets 1000")
			console:execute("snd_restart")
		end
		RegisterScriptCallback("actor_on_item_use", on_item_use)
		RegisterScriptCallback("CUIActorMenu_OnItemFocusReceive", on_item_focus)
		RegisterScriptCallback("CUIActorMenu_OnItemDropped", drag_sight)
	end
end

-- Attaches a sight to a weapon via drag-and-drop.
function drag_sight(sight, weapon, from_slot, to_slot)
	-- Return if not a sight sight.
	if not (sights_table[sight:section()]) then 
		return
	end
	
	-- Validate that the object on the 'to_slot' is a weapon.
	if not (weapon and IsWeapon(weapon)) then 
		return 
	end
	
	-- Can only drag sight to a weapon actor owns.
	local parent = weapon:parent()
	if not (parent and parent:id() == db.actor:id()) then 
		return 
	end

	-- Not a supported sight.
	if not (check_sight(string.sub(sight:section(), 17), weapon:section())) then 
		return 
	end

	-- Attach the sight.
	if (from_slot == EDDListType.iActorBag) and (to_slot == EDDListType.iActorSlot or to_slot == EDDListType.iActorBag) then
		attach_sight(sight, weapon)
	end
end

-- Transfers an item to the actor.
local function transfer_item(id)
	local item = level.object_by_id(id)
	if not (item) then 
		return false 
	end 
	db.actor:transfer_item(item, db.actor)
	return true
end


---------------------------
----- Context Actions -----
---------------------------

-- Called to detach a sight from a weapon.
function context_action_functor(weapon)
	detach_sight(weapon)
end

-- Called to attach a sight to primary weapon.
function context_action_functor_sight_primary(sight)
	attach_sight(sight, get_weapon(3))
end

-- Called to attach a sight to secondary weapon.
function context_action_functor_sight_secondary(sight)
	attach_sight(sight, get_weapon(2))
end

----------------------------
----- Context Functors -----
----------------------------

-- Called to display text for detaching a sight.
function context_functor(weapon)
	-- Return if the weapon is invalid.
	if (not weapon) then
		return
	end
	
	-- Return if the weapon has no parent section.
	local parent_section = system_ini():r_string_ex(weapon:section(), "parent_section")
	if (parent_section == nil or parent_section == "" or weapon:section() == parent_section) then
		return
	end
	
	-- Return if the weapon is not in the actor's inventory.
	local parent = weapon:parent()
	if not (parent and parent:id() == db.actor:id()) then 
		return
	end
	
	-- Return the context option to detach a sight.
	return game.translate_string("st_detach_scope")
end

-- Called to display text for attaching a sight.
function context_functor_sight(sight, slot)
	-- Return if the sight or weapon is invalid.
	local weapon = get_weapon(slot)
	if not (sight and weapon) then
		return
	end
	
	-- A sight has already been attached or none can be used.
	local parent_section = system_ini():r_string_ex(weapon:section(), "parent_section")
	if (parent_section == nil or parent_section == "" or weapon:section() ~= parent_section) then return end
	
	-- Determine whether the weapon is valid for the sight selected.
	if not (check_sight(string.sub(sight:section(), 17), weapon:section())) then
		return
	end
	
	-- Return the context option to attach a sight.
	return game.translate_string("st_attach_scope_to_pistol") .. " " .. alun_utils.get_inv_name(weapon:section())
end

-- Called to attach a sight to the primary weapon.
function context_functor_sight_primary(sight)
	if IsWeapon(db.actor:item_in_slot(3)) then
		return context_functor_sight(sight, 3)
	end
end

-- Called to attach a sight to the secondary weapon.
function context_functor_sight_secondary(sight)
	if IsWeapon(db.actor:item_in_slot(2)) then
		return context_functor_sight(sight, 2)
	end
end

---------------------
----- Callbacks -----
---------------------

-- Called when the cursor focuses on an item.
function on_item_focus(item)
	local parent = item:parent()
	if not (parent and parent:id() == db.actor:id()) then 
		return 
	end
	
	-- No "sights" section found for the weapon.
	if not (system_ini():line_exist(item:section(),"sights")) then return end
	
	-- A sight has already been attached or none can be used.
	local parent_section = system_ini():r_string_ex(item:section(), "parent_section")
	if (parent_section == nil or parent_section == "" or item:section() ~= parent_section) then 
		return 
	end
	
	-- Highlight all sights this item can use.
	local sights = alun_utils.parse_list(system_ini(), item:section(), "sights")
	local inventory = ActorMenu.get_actor_menu()
	if not (sights or (inventory and inventory:IsShown())) then return end
	for i = 1, #sights do 
		inventory:highlight_section_in_slot("wpn_addon_sight_" .. sights[i], EDDListType.iActorBag)
	end
end

-- Called when an item is used.
function on_item_use(item)
	-- Attachments
	if (sights_table[item:section()]) then
		attach_sight(item, get_weapon())
	end
end

----------------------------
----- Sight Management -----
----------------------------

-- Attaches a sight to the weapon.
function attach_sight(item, weapon)
	-- Return if the sight or weapon aren't valid.
	if not (item and weapon) then 
		return 
	end 
	
	-- A sight has already been attached or none can be used.
	local parent_section = system_ini():r_string_ex(weapon:section(), "parent_section")
	if (parent_section == nil or parent_section == "" or weapon:section() ~= parent_section) then 
		return 
	end
	
	-- Modified weapon does not exist and as such can't be used.
	local child_section = (parent_section .. "_" .. string.sub(item:section(), 17))
	if not (system_ini():section_exist(child_section)) then return end
	
	-- Determine whether the sight is valid for the weapon selected.
	if not (check_sight(string.sub(item:section(), 17), weapon:section())) then
		return
	end
	
	-- Create objects for the 'before' and 'after' attachment weapons.
	local old_weapon = alife_object(weapon:id())
	if (old_weapon) then
		local new_weapon = alife():clone_weapon(old_weapon, child_section, old_weapon.position, old_weapon.m_level_vertex_id, old_weapon.m_game_vertex_id, old_weapon.parent_id, false)
		if (new_weapon) then
			-- Release the sight and old unmodified weapon.
			local sight_object = alife_object(item:id())
			alife():release(sight_object, true)
			alife():release(old_weapon, true)
			
			-- Register the new modified weapon.
			alife():register(new_weapon)
		end
	end
end

-- Detaches a sight from the weapon.
function detach_sight(weapon)
	-- Return if the weapon is not valid.
	if not (weapon) then
		return
	end
	
	local wpn_sect = weapon:section()
	-- A sight has not been attached or none can be detached.
	local parent_section = system_ini():r_string_ex(wpn_sect, "parent_section")
	if (parent_section == nil or parent_section == "" or wpn_sect == parent_section) then 
		return 
	end
	
	-- Determine which sight is attached to the weapon.
	-- Create the item in the actor's inventory when found.
	for k, v in pairs(sights_table) do
		if (string.sub(k, 17) == wpn_sect:match("([%w%-]+)$")) then
			give_object_to_actor(k)
			break
		end
	end
	
	-- Create objects for the 'before' and 'after' detachment weapons.
	local old_weapon = alife_object(weapon:id())
	if (old_weapon) then
		local new_weapon = alife():clone_weapon(old_weapon, parent_section, old_weapon.position, old_weapon.m_level_vertex_id, old_weapon.m_game_vertex_id, old_weapon.parent_id, false)
		if (new_weapon) then
			-- Release the old modified weapon.
			alife():release(old_weapon, true)
			
			-- Register the new unmodified weapon.
			alife():register(new_weapon)
		end
	end
end