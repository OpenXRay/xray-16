--'******************************************************
-- Edited by Alundaio
--
-- edited 1/14/2016: Added ability to create squad npcs without specifying a smart
--'******************************************************

-- Current Action: 0 - Reach Target | 1 - Stay Point

local STAY_POINT_IDLE_MIN = 2*60*60
local STAY_POINT_IDLE_MAX = 8*60*60

-- setup location types
local location_types = {}
do -- to localize below
	local locations_ini	= ini_file("misc\\smart_terrain_masks.ltx")
	
	local function itr(section)
		local a,key,val = locations_ini:r_line_ex(section,0,"","")
		location_types[key] = key
	end 
	
	locations_ini:section_for_each(itr)
end

--***********************************************************************************************
--*										INITIALIZATION								  *
--***********************************************************************************************
class "sim_squad_scripted" (cse_alife_online_offline_group)
function sim_squad_scripted:__init(section) super (section)
	self.smart_id 			= nil
	self.current_spot_id 	= nil
	self.current_action 	= nil
	self.current_target_id	= nil
	self.assigned_target_id	= nil
	self:init_squad()
	--if (USE_MARSHAL) then
	--	RegisterScriptCallback("save_state",self.save_state,self)
	--end
	self.first_update 		= false
end

function sim_squad_scripted:init_squad()
	--alun_utils.debug_write("sim_squad_scripted:init_squad")
	local sys_ini			= system_ini()
	local settings_id 		= self:section_name()
	
	self.player_id 			= sys_ini:r_string_ex(settings_id,"faction") or "stalker"
	self.action_condlist	= sys_ini:r_string_to_condlist(settings_id,"target_smart")
	self.death_condlist		= sys_ini:r_string_to_condlist(settings_id,"on_death")
	self.invul_condlist		= sys_ini:r_string_to_condlist(settings_id,"invulnerability")
	
	self.relationship_condlist = sys_ini:r_string_to_condlist(settings_id,"relationship")
	if (self.relationship_condlist) then 
		local new_relation = xr_logic.pick_section_from_condlist(db.actor, self, self.relationship_condlist)
		if (new_relation) and (new_relation == "enemy" or new_relation == "friend" or new_relation == "neutral") then 
			self.relationship = new_relation
		end
	end
	
	local s	= sys_ini:r_string_ex(settings_id, "target_random_smart")
	if (s) then
		self.random_targets = alun_utils.str_explode(s,",") 
	end
	self.idle_time			= sys_ini:r_float_ex(settings_id,"idle_time") or math.random(STAY_POINT_IDLE_MIN,STAY_POINT_IDLE_MAX)	
	
	self.sympathy			= sys_ini:r_float_ex(settings_id,"sympathy")

	self.always_arrived		= sys_ini:r_bool_ex(settings_id,"always_arrived",false)
	self:set_location_types_section("squad_terrain")
	self:set_location_types_section("stalker_terrain")
	self:set_squad_sympathy()
end

function sim_squad_scripted:init_squad_on_load()
	--alun_utils.debug_write(self:name().."init_squad_on_load start")
	self:set_squad_sympathy()
	sim_board.get_sim_board():assign_squad_to_smart(self, self.smart_id)
	self.current_action = 0
	self.need_to_reset_location_masks = true
	--alun_utils.debug_write(self:name().."init_squad_on_load end")
end
--***********************************************************************************************
--*										SCRIPT_TARGET_SELECTION									*
--***********************************************************************************************

function sim_squad_scripted:get_script_target()
	--alun_utils.debug_write("sim_squad_scripted:get_script_target")
	local new_target 
	if (self.scripted_target) then 
		new_target = self.scripted_target
	elseif (axr_task_manager.hostages_by_id[self:commander_id()]) then
		return axr_task_manager.hostages_by_id[self:commander_id()]
	elseif (self.random_targets) then
		if (self.current_action == 0 and self.assigned_target_id == nil) then 
			new_target = self.random_targets[math.random(#self.random_targets)]
		else 
			return self.assigned_target_id
		end
	elseif (self.action_condlist) then
		new_target = xr_logic.pick_section_from_condlist(db.actor, self, self.action_condlist)
	end 
	
	-- prevent companions from moving to actor if they cannot teleport and actor is not on same level
	if (axr_companions.companion_squads[self.id]) then
		local se_obj = alife_object(self:commander_id())
		if (self.online ~= true) and (se_obj and utils.se_obj_load_var(se_obj.id,se_obj:name(),"companion_cannot_teleport")) then
			return self.id
		end
		return 0
	end
		
	if (new_target == "actor") then
		return 0
	end
	
	local smart = new_target and SIMBOARD.smarts_by_names[new_target]
	if (smart) then
		return smart.id
	end
end

function sim_squad_scripted:update()
	--alun_utils.debug_write("sim_squad_scripted:update START")
	cse_alife_online_offline_group.update(self)
	
	if not (self.first_update) then 
		self.first_update = true 
	end

	self:refresh()
	
	if (self.disabled) then
		--alun_utils.debug_write("sim_squad_scripted:update END 4")
		return
	end
	
	if self.need_to_reset_location_masks then
		self:set_location_types()
		self.need_to_reset_location_masks = false
	end
	
	self:check_online_status()
	SendScriptCallback("squad_on_update",self)

	local sim = alife()
	local se_actor = sim:actor()
	self.dist_to_actor = self.position:distance_to(se_actor.position)

	self:check_invulnerability()

	local script_target_id = self:get_script_target()
	if (script_target_id) then
		self:specific_update(script_target_id)
	else
		self:generic_update()
	end
	--alun_utils.debug_write("sim_squad_scripted:update END 2")
end

--***********************************************************************************************
--*										SIMULATION_TARGET_SELECTION		       		*
--***********************************************************************************************
local function can_help_actor(squad)
	if is_empty(xr_combat_ignore.fighting_with_actor_npcs) then
		return false
	end

	local gg = game_graph()
	if gg:vertex(squad.m_game_vertex_id):level_id() ~= gg:vertex(alife():actor().m_game_vertex_id):level_id() then
		return false
	end

	return false
end

local function get_help_target_id(squad)
	if (IsSurvivalMode() and squad.dist_to_actor <= 300) then
		if (squad.player_id == "zombied" or is_squad_monster[squad.player_id]) then
			return 0
		end
	end
	return
end

-- This update is called for all squads with a scripted smart_terrain target
function sim_squad_scripted:specific_update(script_target_id)
	--alun_utils.debug_write(strformat("%s:specific_update",self:name()))
	local sim = alife()
	local se_target = sim:object(script_target_id)
	if not (se_target) then
		return
	end
	
	self.assigned_target_id = script_target_id
	if (self.assigned_target_id == self.id) then 
		return 
	end 
	
	if (self.smart_id ~= self.assigned_target_id and se_target:clsid() == clsid.smart_terrain) then 
		self:assign_smart(se_target,self.smart_id)
	end
	
	if (self.current_action) then
		-- If current action is not finished, then return
		if (self.current_action == 0) then
			-- if not (self.online) then
				-- TeleportSquad(self,se_target.position,se_target.m_level_vertex_id,se_target.m_game_vertex_id)
			-- end
			if (se_target:am_i_reached(self)) then
				se_target:on_after_reach(self)
				self.current_target_id = self.assigned_target_id
				self.current_action = 1
				
				self.stay_time = game.get_game_time()
			end
			return
		elseif (self.current_action == 1 and self.current_target_id == self.assigned_target_id) then
			if (self.stay_time == nil or game.get_game_time():diffSec(self.stay_time) < self.idle_time) then
				return
			end
		end
	end
	
	se_target:on_reach_target(self)
	
	self.assigned_target_id = nil
	self.current_target_id = nil
	self.current_action = 0
	
	for k in self:squad_members() do
		local se_obj = alife_object(k.id)
		if (se_obj) then
			SIMBOARD:setup_squad_and_group(se_obj)
		end
	end
end 

-- This update is called for all squads with no scripted assigned target
function sim_squad_scripted:generic_update()
	--alun_utils.debug_write(strformat("%s:generic_update",self:name()))
	
	if (self.__lock) then 
		return -- so that squad doesn't continously try to find target which lowers FPS
	end 
	
	self.assigned_target_id = get_help_target_id(self) or self.assigned_target_id or self.current_target_id
	
	if (self.current_action) then
		local se_target = simulation_objects.get_server_entity(self.assigned_target_id)
		-- Evaluate current assigned target; make sure it is still valid
		if (se_target and se_target:target_precondition(self,true)) then
			-- If current action is not finished, then return
			
			if (self.smart_id ~= self.assigned_target_id and se_target:clsid() == clsid.smart_terrain) then 
				self:assign_smart(se_target,self.smart_id)
			end
	
			if (self.current_action == 0) then
				if (se_target:am_i_reached(self)) then
					se_target:on_after_reach(self)
					self.current_target_id = self.assigned_target_id
					self.current_action = 1
					self.stay_time = game.get_game_time()
				end
				return
			elseif (self.current_action == 1 and self.current_target_id == self.assigned_target_id) then
				if (se_target.locked == true) or (self.stay_time and game.get_game_time():diffSec(self.stay_time) < self.idle_time) then 
					return
				end
			end
		end
	end
	
	-- Find a new target
	local target = SIMBOARD:get_squad_target(self) or SIMBOARD:get_squad_target(self,false,true)
	if not (target) then
		--printf("squad %s has no target",self:name())
		self:on_reach_target(self)
		
		-- we have to clear AFTER on_reach_target, not BEFORE so we can get location mask of old smart
		self.assigned_target_id = nil
		self.current_target_id = nil
		self.current_action = nil
		self.__lock = true
		return 
	end

	target:on_reach_target(self)
	
	self.assigned_target_id = target.id
	self.current_target_id = nil
	self.current_action = 0
	
	local sim = alife()
	for k in self:squad_members() do
		local se_obj = alife_object(k.id)
		if (se_obj) then
			SIMBOARD:setup_squad_and_group(se_obj)
		end
	end
end

--***********************************************************************************************
--*										MEMBERS_CONTROL											*
--***********************************************************************************************

--' Удаление персонажей отряда
function sim_squad_scripted:remove_squad()
	--alun_utils.debug_write(strformat("START sim_squad_scripted:remove_squad %s",self:name()))
	
	SIMBOARD:assign_squad_to_smart(self, nil)
	SIMBOARD.squads[self.id] = nil
	
	local squad_npcs = {}
	for k in self:squad_members() do
		squad_npcs[k.id] = true
	end
	
	local sim = alife()
	for id,v in pairs(squad_npcs) do
		local se_obj = sim:object(id)
		if (se_obj) then
			local smart_id = se_obj.m_smart_terrain_id --se_obj:smart_terrain_id()
			if (smart_id and smart_id ~= 65535) then
				local smart = alife_object(smart_id)
				if smart ~= nil then
					smart:unregister_npc(self)
				end
			end
			self:unregister_member(id)
			safe_release_manager.release(se_obj)
		end
	end
	self:hide()
	--sim:release(self,true)
	safe_release_manager.release(self)
	--alun_utils.debug_write(strformat("END sim_squad_scripted:remove_squad %s",self:name()))
end

function sim_squad_scripted:remove_npc(npc_id)
	--alun_utils.debug_write(strformat("%s:remove_npc %s",self:name(),npc_id))
	local sim = alife()
	local se_obj = sim:object(npc_id)
	if (se_obj) then
		local smart_id = se_obj:smart_terrain_id()
		if smart_id ~= 65535 then
			local smart = alife_object(smart_id)
			if smart ~= nil then
				smart:unregister_npc(self)
			end
		end
	
		self:unregister_member(se_obj.id)
		safe_release_manager.release(se_obj)
		--sim:release(se_obj, true)
	end
	if self:npc_count() == 0 then
		self.current_action = nil
		if (self.death_condlist) then
			xr_logic.pick_section_from_condlist(db.actor, self, self.death_condlist)
		end
		
		SIMBOARD:assign_squad_to_smart(self, nil)
		SIMBOARD.squads[self.id] = nil
		
		self:hide()
		safe_release_manager.release(self)
		--alife():release(self,true)
	end
end

function sim_squad_scripted:on_npc_death(se_npc,se_killer)
	--alun_utils.debug_write(strformat("%s:on_npc_death %s",self:name(),npc and npc:name()))
	--printf("Squad %s. Killed member %s", tostring(self.id), npc.id)
	--self.sound_manager:unregister_npc(npc.id)
		
	local npc = db.storage[se_npc.id] and db.storage[se_npc.id].object 
	if (npc) then
		local npc_binder = npc:binded_object()
		if (npc_binder) then 
			npc_binder.squad = nil
		end
	end 
	
	self:unregister_member(se_npc.id)

	SendScriptCallback("squad_on_npc_death",self,se_npc,se_killer)

	if self:npc_count() > 0 then
		self:refresh()
		return 
	end 
	
	self.current_action = nil
	if (self.death_condlist) then
		xr_logic.pick_section_from_condlist(db.actor, self, self.death_condlist)
	end
	
	SIMBOARD:assign_squad_to_smart(self, nil)
	SIMBOARD.squads[self.id] = nil

	self:hide()
	safe_release_manager.release(self)
	--alife():release(self,true)
	
	return
end
function sim_squad_scripted:assign_squad_member_to_smart(member_id, smart, old_smart_id)
	local sim = alife()
	local obj = sim:object(member_id)
	if obj ~= nil then
		--printf("    npc [%s] smart [%s]", obj:name(), tostring(obj.m_smart_terrain_id))
		--alun_utils.debug_write(strformat("sim_squad_scripted:assign_squad_member_to_smart npc=%s smart=%s",obj and obj:name(),smart and smart:name()))
		if obj.m_smart_terrain_id == self.smart_id then
			return
		end

		if obj.m_smart_terrain_id ~= 65535 and old_smart_id ~= nil and (obj.m_smart_terrain_id == old_smart_id) and SIMBOARD.smarts[old_smart_id] ~= nil then
			SIMBOARD.smarts[old_smart_id].smrt:unregister_npc(obj)
		end

		if smart ~= nil then
			smart:register_npc(obj)
		end
	end
end

function sim_squad_scripted:assign_smart(smart,old_smart_id)
	--alun_utils.debug_write(strformat("%s:assign_smart %s",self:name(),smart and smart:name()))
	local old_smart = old_smart_id and old_smart_id ~= 65535 and alife_object(old_smart_id)
	if (smart == nil and old_smart == nil) then 
		return 
	end 
	
	if (smart) then
		self.smart_id = smart.id
	end

	for k in self:squad_members() do
		local se_obj = alife_object(k.id)
		if (se_obj) then
			if (old_smart) then
				old_smart:unregister_npc(se_obj)
			end 
			
			if (smart) then 
				smart:register_npc(se_obj)
			end		
		end
	end
end

function sim_squad_scripted:check_invulnerability()
	if self.online ~= true then
		return
	end
	local invulnerability = self.invul_condlist and xr_logic.pick_section_from_condlist(db.actor, self, self.invul_condlist) == "true"
	if (invulnerability) then
		for k in self:squad_members() do
			local npc_st = db.storage[k.id]
			local npc = npc_st and npc_st.object
			if (npc) then
				npc:invulnerable(invulnerability)
			end
		end
	end
end

function sim_squad_scripted:set_location_types_section (section)
	local location = location_types[section]
	if (location) then
		self:add_location_type(location)
	end
end

function sim_squad_scripted:set_location_types(new_smart_name)
	self:clear_location_types()
	
	self:set_location_types_section("stalker_terrain")
	self:set_location_types_section("squad_terrain")
	
	local old_target = self.assigned_target_id and db.smart_terrain_by_id[self.assigned_target_id]
	if (old_target) then 
		self:set_location_types_section(old_target:name())
	end
	
	if (new_smart_name) then 
		self:set_location_types_section(new_smart_name)
	else
		for id,se_obj in pairs(db.smart_terrain_by_id) do
			local props_base = se_obj.props and se_obj.props["base"]
			if (props_base and tonumber(props_base) ~= 0) then
				self:set_location_types_section(se_obj:name())
			end
		end
	end
end

function sim_squad_scripted:add_new_member_forced(section,pos,lvid,gvid)
	local se_obj = alife():create(section,pos,lvid,gvid)
	if (se_obj) then
		self:register_member(se_obj.id)
		local smart = self.smart_id and db.smart_terrain_by_id[self.smart_id]
		if (smart) then 
			smart:register_npc(se_obj)
			SIMBOARD:setup_squad_and_group(se_obj)
		end
	end
end 

function sim_squad_scripted:add_squad_member(spawn_section, spawn_position, lv_id, gv_id)
	--alun_utils.debug_write("sim_squad_scripted:add_squad_member")
	local spawn_sections_ltx = system_ini()
	
	if not (spawn_sections_ltx:section_exist(spawn_section)) then 
		printf("ERROR: npc section %s does not exist!",spawn_section)
		return
	end 
	
	local custom_data = spawn_sections_ltx:r_string_ex(spawn_section,"custom_data") or "default_custom_data.ltx"
	if custom_data ~= "default_custom_data.ltx" then
		printf("INCORRECT npc_spawn_section USED [%s]. You cannot use npc with custom_data in squads", spawn_section)
	end

	local sim = alife()
	local obj = sim:create(spawn_section,spawn_position,lv_id,gv_id)

	self:register_member(obj.id)
	--self.sound_manager:register_npc(obj.id)

	local actor = sim:actor()
	if (simulation_objects.is_on_the_same_level(obj, actor) and spawn_position:distance_to_sqr(actor.position) <= sim:switch_distance()^2) then
		db.spawned_vertex_by_id[obj.id] = lv_id
	end
	-- Alundaio
	SendScriptCallback("squad_on_add_npc",self,obj,spawn_section,spawn_position,lv_id,gv_id)
	-- End Alundaio
	return obj.id
end

function sim_squad_scripted:create_npc(spawn_smart,pos,lvid,gvid)
	--alun_utils.debug_write("sim_squad_scripted:create_npc")
	local ini = system_ini()
	local settings_id = self:section_name()
	local spawn_sections = utils.parse_names(ini:r_string_ex(settings_id, "npc") or "")
	
	local base_spawn_position, base_lvi, base_gvi, spawn_vid
	if (spawn_smart) then
	
		-- Try to look/parse spawn_vid in either squad logic or smart logic
		local spawn_vid = ini:r_string_to_condlist(settings_id,"spawn_vid") or spawn_smart.ini:r_string_to_condlist(settings_id,"spawn_vid")
		if (spawn_vid) then
			local str = xr_logic.pick_section_from_condlist(db.actor,self,spawn_vid)
			if (str and str ~= "" and str ~= "nil") then
				local vid = alun_utils.str_explode(str,":")
				base_lvi = tonumber(vid[1])
				base_spawn_position = level.vertex_position(base_lvi)
				base_gvi = tonumber(vid[2])
			end
		end
		
		-- Try to look/parse spawn_point in either squad logic or smart logic
		if not (base_spawn_position and base_lvi and base_gvi) then
			local spawn_point = ini:r_string_to_condlist(settings_id,"spawn_point") or spawn_smart.ini:r_string_to_condlist(settings_id,"spawn_point")
			if (spawn_point) then 
				local p_path = xr_logic.pick_section_from_condlist(db.actor, self, spawn_point)
				if (p_path and p_path ~= "" and p_path ~= "nil") then 
					local pat = patrol(p_path)
					if (pat) then
						base_spawn_position = pat:point(0)
						base_lvi = pat:level_vertex_id(0)
						base_gvi = pat:game_vertex_id(0)
					end
				end
			end
		end
		
		-- Try spawn_smart.spawn_point
		if not (base_spawn_position and base_lvi and base_gvi) then
			if (spawn_smart.spawn_point) then	
				local pat = patrol(spawn_smart.spawn_point)
				if (pat) then
					base_spawn_position = pat:point(0)
					base_lvi = pat:level_vertex_id(0)
					base_gvi = pat:game_vertex_id(0)
				end
			end
		end
		
		-- if all else fail, spawn on smart
		if not (base_spawn_position and base_lvi and base_gvi) then
			base_spawn_position = spawn_smart.position
			base_lvi = spawn_smart.m_level_vertex_id
			base_gvi = spawn_smart.m_game_vertex_id
		end
		
		self.smart_id = spawn_smart.id
	else 
		base_spawn_position = pos or self.position
		base_lvi = lvid or self.m_level_vertex_id
		base_gvi = gvid or self.m_game_vertex_id
	end 
	
	local npcs_list = {}
	for ind=1,#spawn_sections do
		local id = self:add_squad_member(spawn_sections[ind], base_spawn_position, base_lvi, base_gvi,ind)
		if (id) then
			npcs_list[#npcs_list+1] = id
		end
	end

	local random_spawn = ini:r_string_ex(settings_id,"npc_random")
	if random_spawn ~= nil then
		random_spawn = utils.parse_names(random_spawn)

		local count = ini:r_string_ex(settings_id,"npc_in_squad") or "1,2"
		count = alun_utils.str_explode(count,",")
		count[1] = count[1] and tonumber(count[1])
		count[2] = count[2] and tonumber(count[2]) or count[1]

		local random_count = count[1] and count[2] and math.random(count[1],count[2]) or math.random(1,2)
		random_count = random_count - self:npc_count()
		
		local random_id
		for i = 1,random_count do
			random_id = math.random(1, #random_spawn)
			local id = self:add_squad_member(random_spawn[random_id], base_spawn_position, base_lvi, base_gvi)
			if (id) then
				npcs_list[#npcs_list+1] = id
			end
		end
	elseif #spawn_sections == 0 then
		printf("You are trying to spawn an empty squad [%s]!!!", settings_id)
	end

	if not (spawn_smart) then 
		local smart = self.smart_id and db.smart_terrain_by_id[self.smart_id]
		if (smart) then
			local id 
			for i=1, #npcs_list do 
				id = npcs_list[i]
				local se_obj = id and alife_object(id)
				if (se_obj) then 
					smart:register_npc(se_obj)
					SIMBOARD:setup_squad_and_group(se_obj)
				end
			end
		end
	end 
	
	self:set_squad_relation()
	self:refresh()
end

function sim_squad_scripted:set_squad_sympathy(sympathy)
	--alun_utils.debug_write("sim_squad_scripted:set_squad_sympathy")
	local symp = sympathy or self.sympathy
	if(symp~=nil) then
		local npc
		for k in self:squad_members() do
			npc = db.storage[k.id] and db.storage[k.id].object
			if(npc) then
				game_relations.set_npc_sympathy(npc, symp)
			else
				if(db.goodwill.sympathy==nil) then
					db.goodwill.sympathy = {}
				end
				db.goodwill.sympathy[k.id] = symp
			end
		end
	end
end

function sim_squad_scripted:set_squad_relation(relation)
	--alun_utils.debug_write("sim_squad_scripted:set_squad_relation")
	if (is_squad_monster[self.player_id]) then 
		return
	end
	local rel = relation or self.relationship
	if (rel and (rel == "enemy" or rel == "friend" or rel == "neutral")) then
		local sim = alife()
		for k in self:squad_members() do
			local npc = db.storage[k.id] and db.storage[k.id].object
			if (npc) then
				game_relations.set_npcs_relation(npc, db.actor, rel)
			elseif (k.object) then
				local goodwill = rel == "enemy" and -1000 or rel == "friend" and 1000 or 0
				k.object:force_set_goodwill(goodwill, 0)
			end
		end
	end
end

local function reset_animation(npc)
	--alun_utils.debug_write("sim_squad_scripted:reset_animation")
	local state_mgr = db.storage[npc:id()].state_mgr
	if state_mgr == nil then
		return
	end
	local planner = npc:motivation_action_manager()

	state_mgr.animation:set_state(nil, true)
	state_mgr.animation:set_control()
	state_mgr.animstate:set_state(nil, true)
	state_mgr.animstate:set_control()

	state_mgr:set_state("idle", nil, nil, nil, {fast_set = true})

	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()
	state_mgr:update()

	npc:set_body_state(move.standing)
	npc:set_mental_state(anim.free)
end

function sim_squad_scripted:set_squad_position(position)
	--alun_utils.debug_write("sim_squad_scripted:set_squad_position")
	if self.online == false then
		self:force_change_position(position)
	end

	local cl_object
	for k in self:squad_members() do
		cl_object = db.storage[k.id] and db.storage[k.id].object
		if not (db.offline_objects[k.id]) then
			db.offline_objects[k.id] = {}
		end
		db.offline_objects[k.id].level_vertex_id = level.vertex_id(position)
		if cl_object then
			reset_animation(cl_object)
			cl_object:set_npc_position(position)
		else
			k.object.position = position
		end
	end
end

function sim_squad_scripted:has_detector()
	local sim = alife()
	for k in self:squad_members() do
		local se_obj = sim:object(k.id)
		if se_obj and se_obj:has_detector() then
			return true
		end
	end
	return false
end

function sim_squad_scripted:get_squad_community()
	local squad_community = squad_community_by_behaviour[self.player_id]
	if squad_community == nil then
		printf("squad community is 'nil' for player_id [%s]", self.player_id)
	end
	return squad_community
end

function sim_squad_scripted:has_items_to_sell()
	if not (self.online) then
		return false
	end
	local sim = alife()
	local st
	for k in self:squad_members() do
		st = db.storage[k.id]
		if (st and st.has_items_to_sell) then
			return true
		end
	end
	return false
end

--***********************************************************************************************
--*										SAVE\LOAD												*
--***********************************************************************************************
--[[
function sim_squad_scripted:save_state(m_data)
	--alun_utils.debug_write(strformat("%s:%s sim_squad_scripted:save_state BEFORE",self:name(),self.id))
	m_data.sim_squad_scripted[self.id] = {}
	m_data.sim_squad_scripted[self.id].name = self:name() -- debugging only
	m_data.sim_squad_scripted[self.id].current_target_id = self.current_target_id
	m_data.sim_squad_scripted[self.id].respawn_point_id = self.respawn_point_id
	m_data.sim_squad_scripted[self.id].respawn_point_prop_section = self.respawn_point_prop_section
	m_data.sim_squad_scripted[self.id].smart_id = self.smart_id
	--alun_utils.debug_write(strformat("%s:%s sim_squad_scripted:save_state AFTER",self:name(),self.id))
end 

function sim_squad_scripted:load_state(m_data)
	if not (m_data.sim_squad_scripted and m_data.sim_squad_scripted[self.id]) then 
		return 
	end
	--alun_utils.debug_write("sim_squad_scripted:load_state BEFORE")
	self.current_target_id = m_data.sim_squad_scripted[self.id].current_target_id
	self.respawn_point_id = m_data.sim_squad_scripted[self.id].respawn_point_id
	self.respawn_point_prop_section = m_data.sim_squad_scripted[self.id].respawn_point_prop_section
	self.smart_id = m_data.sim_squad_scripted[self.id].smart_id
	m_data.sim_squad_scripted[self.id] = nil
	--alun_utils.debug_write("sim_squad_scripted:load_state AFTER")
end 
--]]

function sim_squad_scripted:STATE_Write(packet)
	--alun_utils.debug_write("sim_squad_scripted:STATE_Write")
	cse_alife_online_offline_group.STATE_Write (self, packet)
	
	--if (USE_MARSHAL) then 
		--return 
	--end
	
	set_save_marker(packet, "save", false, "sim_squad_scripted")

	packet:w_stringZ(tostring(self.current_target_id))
	packet:w_stringZ(tostring(self.respawn_point_id))
	packet:w_stringZ(tostring(self.respawn_point_prop_section))
	packet:w_stringZ(tostring(self.smart_id))

	set_save_marker(packet, "save", true, "sim_squad_scripted")
end

function sim_squad_scripted:STATE_Read(packet, size)
	--alun_utils.debug_write( strformat("\n%s:STATE_Read start",self:name()) )
	cse_alife_online_offline_group.STATE_Read (self, packet, size)
	
	--if (USE_MARSHAL) then 
		--self:load_state(alife_storage_manager.get_state())
		--self:init_squad_on_load()
		--return 
	--end 
	
	set_save_marker(packet, "load", false, "sim_squad_scripted")	

	self.current_target_id = packet:r_stringZ()
	if self.current_target_id == "nil" then
		self.current_target_id = nil
	else
		self.current_target_id = tonumber(self.current_target_id)
	end
	self.respawn_point_id = packet:r_stringZ()
	if self.respawn_point_id == "nil" then
		self.respawn_point_id = nil
	else
		self.respawn_point_id = tonumber(self.respawn_point_id)
	end
	self.respawn_point_prop_section = packet:r_stringZ()
	if self.respawn_point_prop_section == "nil" then
		self.respawn_point_prop_section = nil
	end
	self.smart_id = packet:r_stringZ()
	if self.smart_id == "nil" then
		self.smart_id = nil
	else
		self.smart_id = tonumber(self.smart_id)
	end
	self:init_squad_on_load()
	
	set_save_marker(packet, "load", true, "sim_squad_scripted")
	--alun_utils.debug_write( strformat("%s:STATE_Read end",self:name()) )
end
--***********************************************************************************************
--*										SERVER_OBJECT											*
--***********************************************************************************************

function sim_squad_scripted:on_register()
	--alun_utils.debug_write( strformat("%s:on_register start",self:name()) )
	cse_alife_online_offline_group.on_register( self )
	story_objects.check_spawn_ini_for_story_id(self)
	sim_board.get_sim_board().squads[self.id] = true
	--simulation_objects.register(self)
	SendScriptCallback("squad_on_register",self)
	--alun_utils.debug_write( strformat("%s:on_register end",self:name()) )
end
function sim_squad_scripted:on_unregister()
	--alun_utils.debug_write("sim_squad_scripted:on_unregister")
	SendScriptCallback("squad_on_unregister",self)
	story_objects.unregister(self.id)
	SIMBOARD.squads[self.id] = nil
	SIMBOARD:assign_squad_to_smart(self, nil)
	--simulation_objects.unregister(self)
	if self.respawn_point_id ~= nil then
		local smart = alife_object(self.respawn_point_id)
		if smart == nil then
			return
		end
		if smart.already_spawned ~= nil and smart.already_spawned[self.respawn_point_prop_section] ~= nil then
			smart.already_spawned[self.respawn_point_prop_section].num = smart.already_spawned[self.respawn_point_prop_section].num - 1
		end
	end
	--if (USE_MARSHAL) then 
	--	UnregisterScriptCallback("save_state",self)
	--end
	cse_alife_online_offline_group.on_unregister(self)
end

function sim_squad_scripted:check_online_status()
	local b = nil
	if (get_object_story_id(self.id)) then 
		-- don't enforce any rule
	elseif (self.__lock) then -- couldn't find a target
		b = false
	elseif (IsSurvivalMode()) then
		b = true
	elseif (self.force_online) then -- for tasks
		b = true
	elseif (axr_companions.companion_squads[self.id]) then 
		b = true
	elseif not (level_weathers.valid_levels[level.name()]) then -- underground levels
		-- don't enforce any rule
	else
		if (is_squad_monster[self.player_id]) then -- monster behaviors
			local hour = level.get_time_hours()
			if (self.player_id == "monster_predatory_day") then 
				-- Monster will not come online during the hours of (9PM till 5AM)
				if (hour <= 5 or hour >= 22) then
					b = false 
				end
			elseif (self.player_id == "monster_zombied_day") then 
				-- Monster will not come online during the hours of (7PM till 5AM)
				if (hour <= 5 or hour >= 19) then
					b = false
				end
			elseif (self.player_id == "monster_predatory_night") then 
				-- Monster will not come online during the hours of (5AM till 7PM)
				if (hour >= 5 and hour <= 19) then
					b = false
				end
			elseif (self.player_id == "monster_zombied_night") then 
				-- Monster will not come online during the hours of (5AM till 7PM)
				if (hour >= 5 and hour <= 19) then
					b = false
				end
			end
		end
		if (db.actor) then
			if (db.actor:has_info("enforce_online_exclusion")) then -- For story needs
				if (self.online) then -- exclude from coming online except if already online or storied
					if (self.was_forced_offline or self.position:distance_to(db.actor:position()) >= 2500) then
						self.was_forced_offline = false
						b = false -- switch online to offline
					end
				else
					b = false -- all simulation already offline, refuse to come online while actor has info
				end
			else
				if not (self.online) then
					local dist = axr_main.config:r_value("mm_options","excl_dist",2) or 0
					if (dist > 0 and not db.actor:has_info("actor_is_sleeping")) then 
						if (self.position:distance_to(db.actor:position()) <= dist) then
							b = false -- force offline for online exclusion
						end
					end
				end
			end
		end
	end
	self.forced_online_status = b
end

function sim_squad_scripted:can_switch_offline()
	--[[
	if (self.current_action == 1) then 
		local current_target = self.current_target_id and alife_object(self.current_target_id)
		if (current_target.online and current_target.faction_controlled and current_target.faction_war_in_progress == true) then
			--printf("forced online %s",current_target:name())
			return false
		end
	end
	--]]
	
	if not (cse_alife_online_offline_group.can_switch_offline(self)) then 
		return false
	end
	
	if (self.forced_online_status == true) then
		return false
	end

	return true
end

function sim_squad_scripted:can_switch_online()
	-- important to check with inherited method first if it's okay to switch online, otherwise this leads to
	-- crash saying 'object with ID already exists' when returning false and object is already online
	if not cse_alife_online_offline_group.can_switch_online(self) then 
		return false
	end
	
	if (self.forced_online_status == false) then 
		return false
	end
	
    return true
end
function sim_squad_scripted:switch_offline()
	cse_alife_online_offline_group.switch_offline(self)
end
function sim_squad_scripted:switch_online()
	-- if (DEV_DEBUG) then
	--	printf("sim_squad_scripted:switch_online() [%s]",self:name())
	-- end
	cse_alife_online_offline_group.switch_online(self)
end

--***********************************************************************************************
--*										MAP LOCATION											*
--***********************************************************************************************

function sim_squad_scripted:refresh()
	if(self:commander_id()==nil) then
		self:hide()
		return
	end
	self:show()
end

function sim_squad_scripted:hide()
	if(self.current_spot_id==nil) or (self.spot_section==nil) then
		return
	end
	level.map_remove_object_spot(self.current_spot_id, self.spot_section)
	self.current_spot_id = nil
	self.spot_section = nil
end

function sim_squad_scripted:show()
	if self.show_disabled then
		self:hide()
		return
	end

    if(level.map_has_object_spot(self:commander_id(), "ui_pda2_trader_location")~=0) or
	(level.map_has_object_spot(self:commander_id(), "ui_pda2_mechanic_location")~=0) or
	(level.map_has_object_spot(self:commander_id(), "ui_pda2_scout_location")~=0) or
	(level.map_has_object_spot(self:commander_id(), "ui_pda2_quest_npc_location")~=0) or
	(level.map_has_object_spot(self:commander_id(), "ui_pda2_medic_location")~=0) then
		self.show_disabled = true
		return
	end

	if self.current_spot_id ~= self:commander_id() then
		self:hide()
		self.current_spot_id = self:commander_id()
		self:show()
		return
	end
	local spot = ""

	if (DEV_DEBUG and axr_main.config:r_value("mm_options","enable_debug_hud",1,false) == true) then
		if (DEV_DEBUG_HOLD_ACTION_1) then 
			if (self.assigned_target_id ~= nil and smart_terrain.nearest_to_actor_smart.id == self.assigned_target_id) then 
				spot = "storyline_task_location"
			end
		else
			spot = "storyline_task_location"
		end
	elseif not(is_squad_monster[self.player_id]) then
		local relation = game_relations.get_squad_relation_to_actor_by_id(self)
		if(relation=="friends") then
			spot = "alife_presentation_squad_friend"
		elseif(relation=="neutral") then
			spot = "alife_presentation_squad_neutral"
		end
	end

	if (spot~="") then
		if spot == self.spot_section then
			level.map_change_spot_hint(self.current_spot_id, self.spot_section, self:get_squad_props())
			return
		end
		if self.spot_section == nil then
			level.map_add_object_spot(self.current_spot_id, spot, self:get_squad_props())
		else
			level.map_remove_object_spot(self.current_spot_id, self.spot_section)
			level.map_add_object_spot(self.current_spot_id, spot, self:get_squad_props())
		end
		self.spot_section = spot
	elseif (self.spot_section~=nil) then
		level.map_remove_object_spot(self.current_spot_id, self.spot_section)
		self.spot_section = nil
	end
end

function sim_squad_scripted:get_squad_props()
	if (DEV_DEBUG and axr_main.config:r_value("mm_options","enable_debug_hud",1,false) == true) then
		local assigned_target = self.assigned_target_id and alife_object(self.assigned_target_id)
		local current_target = self.current_target_id and alife_object(self.current_target_id)

		local t = "forced_online_status=%s\\n%s\\n\\n%s\\n\\nnpcs=%s\\n\\ncurrent_target=%s\\nassigned_target=%s\\n\\n"
		t = strformat(t,tostring(self.forced_online_status),self.disabled and "[disabled]" or "",self:name(),self:npc_count(),self.current_target_id == 0 and "actor" or current_target and current_target:name(),self.assigned_target_id == 0 and "actor" or assigned_target and assigned_target:name())

		if (self.current_action) then
			if (self.current_action == 0) then 
				t = t .. "Trying to Reach Target"
			elseif (self.current_action == 1) then 
				t = t .. "Stay On Target"
			end
			
			if (self.current_action == 1 and self.stay_time) then
				t = strformat("%s = %s (%s)",t,tostring(self.idle_time - game.get_game_time():diffSec(self.stay_time)),self.idle_time)
			end
		end

		return t
	else
		return game.translate_string(self.player_id)
	end
end

--***********************************************************************************************
--*										SIMULATION_TARGET_SQUAD									*
--***********************************************************************************************
function sim_squad_scripted:get_location()
	return self.position, self.m_level_vertex_id, self.m_game_vertex_id
end

-- called from engine
function sim_squad_scripted:get_current_task()
	--alun_utils.debug_write("sim_self_scripted:get_current_task")
	local se_target = self.assigned_target_id and simulation_objects.get_server_entity(self.assigned_target_id)
	if (se_target) then
		local npc_info = se_target.npc_info and se_target.npc_info[self:commander_id()]
		if (npc_info and npc_info.job) then
			return npc_info.job.alife_task or se_target:get_alife_task() or self:get_alife_task()
		end
		return se_target:get_alife_task()
	end
	return self:get_alife_task()
end

function sim_squad_scripted:am_i_reached(squad)
	return self:npc_count() == 0
end

function sim_squad_scripted:on_after_reach(squad)
	squad.current_action = nil
	squad.current_target_id = nil
end

function sim_squad_scripted:on_reach_target(squad)
	--alun_utils.debug_write("sim_squad_scripted:on_reach_target")
	squad:set_location_types()
 	for k in squad:squad_members() do
		db.spawned_vertex_by_id[k.id] = nil
		if db.offline_objects[k.id] ~= nil then
			db.offline_objects[k.id] = db.offline_objects[k.id] and empty_table(db.offline_objects[k.id])
		end
		db.spawned_vertex_by_id[k.id] = nil
	end
	SIMBOARD:assign_squad_to_smart(squad, nil)
end

function sim_squad_scripted:get_alife_task()
	return CALifeSmartTerrainTask(self.m_game_vertex_id, self.m_level_vertex_id)
end

local smarts_by_no_assault_zones = {
									["zat_a2_sr_no_assault"] 	= "zat_stalker_base_smart",
									["jup_a6_sr_no_assault"] 	= "jup_a6",
									["jup_b41_sr_no_assault"] 	= "jup_b41"
}

function sim_squad_scripted:sim_available()
	return false 
	--[[
	if self.smart_id == nil then
		return true
	end

	local smart = simulation_objects.get_server_entity(self.smart_id)
	if not (smart) then
		return false
	end

	-- Can't be targetted by other squads if at base or trade prop smart
	if (smart.props and smart.props.base and smart.props.base > 0) then
		return false
	end

	return true
	--]]
end

function sim_squad_scripted:target_precondition(squad)
	if (self.id == squad.id) then 
		return true 
	end 
	
	if (sim_board.general_squad_precondition(squad,self)) then 
		return true 
	end

	return false
end

function sim_squad_scripted:evaluate_prior(squad)
	return simulation_objects.evaluate_prior(self, squad)
end
