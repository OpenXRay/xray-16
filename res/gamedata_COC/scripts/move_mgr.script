local dist_walk = 10 -- < dist_run
local dist_run = 2500

local walk_min_time = 3000
local run_min_time = 2000

local keep_state_min_time = 1500 -- переключившись в состояние (бег, ходьба, спринт), не переключаться в другое N ms

local default_wait_time = 10000
local default_state_standing = "guard"
local default_state_moving1 = "patrol"
local default_state_moving2 = "patrol"
local default_state_moving3 = "patrol"

arrival_before_rotation = 0
arrival_after_rotation = 1

local state_none = 0
local state_moving = 1
local state_standing = 2

local sync = {}
-------------------------------------------------------------------------------------------------------------------------
function choose_look_point(patrol_look, path_look_info, search_for)
	local this_val -- значение флагов текущей точки
	local pts_found_total_weight = 0 -- количество найденных точек (с нужными флагами)
	local pt_chosen_idx = nil -- индекс выбранной точки
	local r
	local num_equal_pts = 0
	local point_look_weight
	for look_idx = 0, patrol_look:count() - 1 do
		this_val = path_look_info[look_idx].flags
		if this_val:equal(search_for) then
			num_equal_pts = num_equal_pts + 1
			-- Нашли точку с нужными флагами, но поскольку в пути могут быть еще такие-же
			-- точки, возьмем текущую только с некоторой вероятностью:
			-- Шанс, с которым на точку посмотрит персонаж:
			point_look_weight = path_look_info[look_idx]["p"]
			if point_look_weight then
				point_look_weight = tonumber(point_look_weight)
			else
				point_look_weight = 100 -- по умолчанию у всех точек вес = 100
			end
			pts_found_total_weight = pts_found_total_weight + point_look_weight
			r = math.random(1, pts_found_total_weight)
			if r <= point_look_weight then
				pt_chosen_idx = look_idx
			end
		end
	end
	return pt_chosen_idx, num_equal_pts
end

-------------------------------------------------------------------------------------------------------------------------
class "move_mgr"
function move_mgr:__init(npc)
	if npc == nil then
		printf("move_mgr:__init() - npc is nil, please update the script")
	end
	self.object = npc
	self.target = {}
	self.cbs = {}
end

function move_mgr:initialize(npc)
	self.object:set_callback(callback.patrol_path_in_point, self.waypoint_callback, self)
end

function move_mgr:disable()
	self.object:set_callback(callback.patrol_path_in_point,nil)
	self.object:set_path_type(game_object.level_path)
	self.__disable = true
end

--' Удостоверяется, что пути и флажки на них проставлены корректно
function move_mgr:validate_paths()
	if self.no_validation then
		return
	end
	local patrol_walk_count = self.patrol_walk:count()
	if patrol_walk_count == 1 then
		if self.path_walk_info[0].flags:get() == 0 then
			printf("object '%s': path_walk '%s' has 1 waypoint, but has no flags",self.object:name(), self.path_walk)
		end
	end
end

function move_mgr:extrapolate_callback(npc)
	if (self.__disable) then
		return
	end
	self.can_use_get_current_point_index = true
	self.current_point_init_time = time_global()
	self.current_point_index = self.object:get_current_point_index()
end

function move_mgr:standing_on_terminal_waypoint()
	if (self.__disable) then
		return
	end

	for idx = 0, self.patrol_walk:count() - 1 do
		if utils.stalker_at_waypoint(self.object, self.patrol_walk, idx) and
			 self.patrol_walk:terminal(idx) then
			return true, idx
		end
	end

	return false
end

--' Может быть вызвано внешним скриптом после вызова reset() и до вызова finalize()
--' Возвращает true, если персонаж прибыл в конечную точку пути
function move_mgr:at_terminal_waypoint()
	return self.at_terminal_waypoint_flag
end

--' Из move_cb вернуть true, чтобы приостановить работу схемы. Чтобы продолжить движение,
--' нужно вызвать метод set_movement_state, который включит перемещение по вейпоинтам с нужной
--' скоростью.
function move_mgr:reset(path_walk, path_walk_info, path_look, path_look_info, team, suggested_state, move_cb_info, no_validation, continue, use_default_sound)
	--printf("move_mgr:reset() [%s]", self.object:name())
	
	--alun_utils.debug_write("move_mgr:reset")

	if not (path_walk_info) then 
		printf("ERROR: no path_walk_info  npc=%s path_walk=%s",npc and npc:name(),path_walk)
		self.__disable = true
	end 
	
	if (self.__disable) then
		return
	end

	--' сколько ждать в точке, где играем анимацию
	self.pt_wait_time = not self.pt_wait_time and default_wait_time or self.pt_wait_time

	--' Запоминаем массив целиком на случай, если придется себя сбросить, повторно
	--' вызвав reset():
	self.suggested_state = suggested_state
	--' После этого распарсиваем массив:
	if not suggested_state then
		self.default_state_standing = default_state_standing
		self.default_state_moving1 = default_state_moving1
		self.default_state_moving2 = default_state_moving2
		self.default_state_moving3 = default_state_moving3
	else
		self.default_state_standing = suggested_state.standing or default_state_standing
		self.default_state_moving1 = suggested_state.moving or default_state_moving1
		self.default_state_moving2 = suggested_state.moving or default_state_moving2
		self.default_state_moving3 = suggested_state.moving or default_state_moving3
	end

	self.default_state_standing = xr_logic.parse_condlist(self.object, "move_mgr", "def_state", self.default_state_standing)
	self.default_state_moving1  = xr_logic.parse_condlist(self.object, "move_mgr", "def_state", self.default_state_moving1)
	self.default_state_moving2  = xr_logic.parse_condlist(self.object, "move_mgr", "def_state", self.default_state_moving2)
	self.default_state_moving3  = xr_logic.parse_condlist(self.object, "move_mgr", "def_state", self.default_state_moving3)

	--' С момента включения схемы должна пройти как минимум секунда, прежде чем
	--' проверять состояние синхронизации с другими сталкерами (иначе после лоада
	--' они могут не успеть заспавниться).
	self.syn_signal_set_tm = time_global() + 1000
	self.syn_signal = nil

	self.move_cb_info = move_cb_info

	--' Возможные изменения
	--' Изменилась команда
	if team ~= self.team then
		self.team = team
		if self.team then
			local s = sync[self.team]
			if not s then
				sync[self.team] = {}
				s = sync[self.team]
			end
			s[self.object:id()] = false -- not synchronized
		end
	end

	--' Изменились пути
	if self.path_walk ~= path_walk or self.path_look ~= path_look then

		self.no_validation = no_validation

		self.path_walk = path_walk
		self.patrol_walk = patrol(path_walk)
		if not self.patrol_walk then
			printf("object '%s': unable to find path_walk '%s' on the map",self.object:name(), path_walk)
			self:disable()
			return
		end

		--[[
		local cnt = self.patrol_walk:count()
		for i=0,cnt-1 do
			if not (self.object:accessible(self.patrol_walk:level_vertex_id(i)) and self.patrol_walk:level_vertex_id(i) < 4294967295) then
				printf("move_mgr:reset: %s: point %s is inaccessible to npc on patrol path %s",self.object:name(),i,path_walk)
				self:disable()
				return
			end
		end

		local gg = game_graph()
		if (gg:vertex(self.object:game_vertex_id()):level_id() ~= gg:vertex(self.patrol_walk:game_vertex_id(0)):level_id()) then
			printf("move_mgr:reset: %s: trying to use patrol path %s that exists on another level then object",self.object:name(),path_walk)
			self:disable()
			return
		end
		--]]
		
		if not path_walk_info then
			printf("object '%s': path_walk ('%s') field was supplied, but path_walk_info field is nil",self.object:name(), path_walk)
			self:disable()
			return
		end
		self.path_walk_info = path_walk_info

		if path_look then
			if not path_look_info then
				printf("object '%s': path_look ('%s') field was supplied, but path_look_info field is nil",self.object:name(), path_look)
				return
			end
			self.patrol_look = patrol(path_look)
			if not self.patrol_look then
				printf("object '%s': unable to find path_look '%s' on the map",self.object:name(), path_look)
			end
		else
			self.patrol_look = nil
		end
		self.path_look = path_look
		self.path_look_info = path_look_info

	 --'self:validate_paths()

		self.at_terminal_waypoint_flag = false

		if (self.object:character_community() == "zombied" and not get_object_story_id(self.object:id())) then -- in the case zombied has some kind of scripted action
			self.cur_state_standing = self.default_state_standing
		else
			self.cur_state_standing = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_standing)
		end 
		
		self.cur_state_moving = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_moving1)

		self.retval_after_rotation = nil
		self.sound_after_anim_start = nil

		--' Пока этот флаг не станет true (он будет установлен в extrapolate_callback), нельзя использовать
		--' значение, которое возвращает get_current_point_index().
		self.can_use_get_current_point_index = false
		self.current_point_index = nil
		self.walk_until = time_global() + walk_min_time
		self.run_until = time_global() + walk_min_time + run_min_time
		self.keep_state_until = time_global()


		self.last_index = nil
		self.last_look_index = nil

		self.use_default_sound = use_default_sound

		self.object:patrol_path_make_inactual()
	end
	self:setup_movement_by_patrol_path()
end

--' продолжить движение со следующей точки, а не с ближайшей.
--' состояние move manager-a не сбрасывается.
function move_mgr:continue()
	if (self.__disable) then
		return
	end

	--printf("_bp: object '%s': continue moving", self.object:name())
	self:setup_movement_by_patrol_path()
end

function move_mgr:setup_movement_by_patrol_path()
	--alun_utils.debug_write("move_mgr:setup_movement_by_patrol_path")
	
	if (self.__disable) then
		return
	end

	self.object:set_path_type(game_object.patrol_path)
	self.object:set_detail_path_type(move.line)

	if self.current_point_index then
		self.object:set_start_point(self.current_point_index)
		self.object:set_patrol_path(self.path_walk, patrol.next,    patrol.continue, true)
	else
		self.object:set_patrol_path(self.path_walk, patrol.nearest, patrol.continue, true)
	end

	self.state = state_moving

	local is_term, idx = self:standing_on_terminal_waypoint()
	if is_term then
		--printf("_bp: object '%s': TERMINAL WAYPOINT", self.object:name())
		-- Стоим на терминальной вершине пути  - сразу иммитировать прибытие
		self:waypoint_callback(self.object, nil, idx)
	else
		-- Реально идем в вершину
		self:update_movement_state()
	end

end

function move_mgr:arrived_to_first_waypoint()
	return self.last_index ~= nil
end


--' Проверка синхронизации с остальными солдатами на пути.
--' Возвращает true, если дальнейшее движение разрешено.
function move_mgr:sync_ok()
	if self.team then
		local s = sync[self.team]
		local self_id = self.object:id()
		for k, v in pairs(s) do
			local obj = level.object_by_id(k)
			if obj then
				if v ~= true then
					return false
				end
			else
				sync[self.team][k] = nil
			end
		end
	end
	return true
end

function move_mgr:update()
	--alun_utils.debug_write("move_mgr_update")
	if (self.__disable) then
		return
	end

	local tg = time_global()
	
	if not (self.syn_signal_set_tm) then
		self.syn_signal_set_tm = tg + 1000 
	end 
	
	if self.syn_signal and tg >= self.syn_signal_set_tm then
		if self:sync_ok() then
			self:scheme_set_signal(self.syn_signal)
			self.syn_signal = nil
		end
	end

	if self.can_use_get_current_point_index and not self:arrived_to_first_waypoint() then
		if (self.keep_state_until and tg >= self.keep_state_until) then
			self.keep_state_until = tg + keep_state_min_time

			local cur_pt = self.current_point_index
			-- self.patrol_walk здесь по идее то же самое, что вернет patrol(self.object:patrol()),
			-- поэтому использую его для оптимизации.
			local dist = self.object:position():distance_to(self.patrol_walk:point(cur_pt))
			--printf("_bp: move_mgr: distance to destination waypoint: %d", dist)
			if dist <= dist_walk or tg < self.walk_until then
				self.cur_state_moving = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_moving1)
			elseif dist <= dist_run or tg < self.run_until then
				self.cur_state_moving = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_moving2)
			else
				self.cur_state_moving = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_moving3)
			end
			self:update_movement_state()
		end
		return
	end
end

function move_mgr:set_current_state_moving(state)
	self.ovr_state_moving = state
	if (state) then
		self:update_movement_state()
	end
end

function move_mgr:set_current_state_standing(state)
	self.ovr_state_standing = state
	if (state) then
		self:update_standing_state()
	end
end 

function move_mgr:finalize(npc)
	if self.team then
		sync[self.team][self.object:id()] = nil
	end
	self.__disable = nil
	-- чтобы избежать дальнейшего движения по пути при установке рестрикторов
	self.object:set_path_type(game_object.level_path)
end

--'-----------------------------------------------------------------------------
--' IMPLEMENTATION
--'-----------------------------------------------------------------------------
function move_mgr:update_movement_state()
	if (self.__disable) then
		return
	end

	--printf("%s UPDATE movement state to %s", self.object:name(), self.cur_state_moving)
	--[[
	if (self.current_point_index and self.current_point_index > 0) then
		local a = self.patrol_walk:point(self.current_point_index)
		local b = a and self.patrol_walk:point(self.current_point_index-1)
		if (a and b) then
			local angle = utils.angle_diff(b,a)
			--printf("angle=%s",angle)
			if (angle >= 85) then
				state_mgr.set_state(self.object,"climb")
				return
			end
		end
	end
	--]]

	state_mgr.set_state(self.object, self.ovr_state_moving or self.cur_state_moving,nil, nil, self.target)
end

function move_mgr:set_target(pos,obj,dir)
	self.target.look_position = pos 
	self.target.look_object = obj 
	self.target.look_dir = dir
end
function move_mgr:clear_target()
	self.target.look_position = nil 
	self.target.look_object = nil 
	self.target.look_dir = nil
end 

function move_mgr:update_standing_state(look_pos, snd)
	--printf("_bp [%s]: update_standing_state: snd='%s', pt_wait_time = %s path = %s", self.object:name(), utils.to_str(snd), utils.to_str(self.pt_wait_time),  self.path_walk)
	
	-- absurd, but it's just to avoid continous table creation
	local old_pos = self.target.look_position
	self.target.look_position = look_pos 
	self.cbs.obj = self
	self.cbs.func = self.time_callback
	self.cbs.turn_end_func = self.turn_end_callback
	
	state_mgr.set_state(self.object, self.ovr_state_standing or self.cur_state_standing,self.cbs,self.pt_wait_time,self.target,nil,snd)
		
	self.target.look_position = old_pos
	self.cbs.obj = nil
	self.cbs.func = nil
	self.cbs.turn_end_func = nil
end

function move_mgr:time_callback()
	--printf("_bp [%s]: time_callback", self.object:name())
	local sigtm = self.path_look_info and self.path_look_info[self.last_look_index] and self.path_look_info[self.last_look_index]["sigtm"]
	if sigtm then
		self:scheme_set_signal(sigtm)
	end
	--' Если нет активной схемы - игнорировать.
	if db.storage[self.object:id()].active_scheme == nil then
		return
	end
	if self.last_index and self.patrol_walk:terminal(self.last_index) then
		if utils.stalker_at_waypoint(self.object, self.patrol_walk, self.last_index) then
			--' Если стоим на конечной точке пути и с нее никуда не сдвинулись,
			--' сразу иммитируем callback на прибытие, чтобы включить look.
			self:waypoint_callback(self.object, nil, self.last_index)
			return
		end
		--' Стоим на конечной точке пути, но неточно. Чтобы вернуться на ближайшую
		--' точку пути, сбрасываем схему. Обратите внимаине, что здесь нельзя
		--' просто вызвать update_movement_state, потому что мы УЖЕ были в
		--' конечной точке пути и дальше идти некуда, а reset_scheme сбросит
		--' настройки movement manager-а и выберет ближайшую точку, куда и пойдет.
		self:reset(self.path_walk, self.path_walk_info,
			self.path_look, self.path_look_info,
			self.team,
			self.suggested_state,
			self.move_cb_info,
			self.no_validation)
	else
		self:update_movement_state() -- идти дальше
		local syn = self.path_look_info and self.path_look_info[self.last_look_index] and self.path_look_info[self.last_look_index]["syn"]
		if syn then
			printf("object '%s': path_walk '%s': syn flag used on non-terminal waypoint",
				self.object:name(), self.path_walk)
		end
	end
end

function move_mgr:scheme_set_signal(sig)
	local npc_id = self.object:id()
	local stor = db.storage[npc_id]
	--printf("_bp: object '%s': move_mgr: scheme_set_signal '%s', active scheme '%s'",
	--	self.object:name(), sig, utils.to_str(stor.active_scheme))
	if stor ~= nil and stor[stor.active_scheme] ~= nil then
		local signals = stor[stor.active_scheme].signals
		if signals ~= nil then
			 signals[sig] = true
		end
	end
end

function move_mgr:turn_end_callback()
	local syn = self.path_look_info and self.path_look_info[self.last_look_index] and self.path_look_info[self.last_look_index]["syn"]
	if syn then
		self.syn_signal = self.path_look_info[self.last_look_index]["sig"]
		if not self.syn_signal then
			printf("object '%s': path_look '%s': syn flag uset without sig flag", self.object:name(), self.path_look)
		end

		-- Отметить, что мы сами уже прибыли в точку синхронизации:
		if self.team then
			sync[self.team][self.object:id()] = true
		end

	else
		local sig = self.path_look_info and self.path_look_info[self.last_look_index] and self.path_look_info[self.last_look_index]["sig"]
		if sig then
			self:scheme_set_signal(sig)
		else
			self:scheme_set_signal("turn_end")
		end
	end

	local anim_synced_snd = nil
	if self.sound_after_anim_start then
		-- Проиграть звук сразу после окончания поворота:
		anim_synced_snd = self.sound_after_anim_start
		self.sound_after_anim_start = nil
	end

	if self.retval_after_rotation then
		if not self.move_cb_info then
			printf("object '%s': path_look '%s': ret flag is set, but " ..
				"callback function wasn't registered in move_mgr:reset()",
				self.object:name(), self.path_look)
		end
		--' Отключаем таймер путем установки того же самого состояния, но без таймера,
		--' затем вызываем callback.
		--' Если callback вернул false, т.е. решил не вмешиваться в перемещение,
		--' то включаем опять таймер.
		--' Если callback вернул true - не восстанавливаем таймер т.к. это могли сделать в
		--' самом callback-е.

		--' 1) Отключаем таймер
		state_mgr.set_state(self.object, self.cur_state_standing, nil, nil, nil)
		--' 2) Вызываем callback
		if not self.move_cb_info then
			printf("object '%s': path_look '%s': ret flag is set, but " ..
				"callback function wasn't registered in move_mgr:reset()",
				self.object:name(), self.path_look)
		end

		if self.move_cb_info.func(self.move_cb_info.obj, this.arrival_after_rotation, self.retval_after_rotation, self.last_index)
		then
			--' Callback решил перехватить управление перемещением, не восстанавливаем таймер
			return
		end
		--' Callback не перехватил управление, нужно восстановить таймер:
		local look_pos = self.patrol_look:point(self.last_look_index)
		self:update_standing_state(look_pos, anim_synced_snd)
	end
end

function move_mgr:waypoint_callback(obj, action_type, index)
	--printf("move_mgr:waypoint_callback(): name=%s, index=%d", self.object:name(), index)
	if (self.__disable) then
		return
	end

	--printf("%s index=%s #path_walk_info=%s",obj:name(),index,#self.path_walk_info)
	
	if index == -1 or index == nil then
		--printf("ERROR: move_mgr: waypoint_callback: index is -1 or nil")
		return
	end
	
	self.last_index = index

	if self.patrol_walk:terminal(index) then
		self.at_terminal_waypoint_flag = true
	end

	local suggested_state_moving = self.path_walk_info[index]["a"]
	if suggested_state_moving then
		self.cur_state_moving = xr_logic.pick_section_from_condlist(db.actor, self.object, suggested_state_moving)
		if tostring(self.cur_state_moving) == "true" then
			--print_table(suggested_state_moving)
			printf("!!!!!")
		end
	else
		self.cur_state_moving = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_moving1)
		if tostring(self.cur_state_moving) == "true" then
			printf("!!!!!")
		end
	end


	local retv = self.path_walk_info[index]["ret"]
	if retv then
		--printf("retv = %s", retv)
		local retv_num = tonumber(retv)

		if not self.move_cb_info then
			printf("object '%s': path_walk '%s': ret flag is set, but " ..
				"callback function wasn't registered in move_mgr:reset()",
				self.object:name(), self.path_walk)
		end
		if self.move_cb_info.func(self.move_cb_info.obj, this.arrival_before_rotation, retv_num, index) then
			return
		end
	end

	local path_end = index == #self.path_walk_info --index == #self.path_walk_info - 1
	local sig = self.path_walk_info[index]["sig"]
	if sig then
		self:scheme_set_signal(sig)
	elseif path_end then
		self:scheme_set_signal("path_end")
	end
	
	if not (path_end) then
		local stop_probability = self.path_walk_info[index]["p"]
		if (stop_probability == nil or tonumber(stop_probability) < math.random(1, 100)) then
			self:update_movement_state() --' идти дальше
			return
		end
	end
	
	if not (self.patrol_look) then
		self.cur_state_standing = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_standing)
		self:update_standing_state(look_pos, self.sound_after_anim_start)
		self.state = state_standing
		self:update()
		return
	end 
	
	-- Значение флагов точки, которую будем искать:
	local search_for = self.path_walk_info[index].flags
	if search_for:get() == 0 then
		self.cur_state_standing = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_standing)
		self:update_standing_state(self.patrol_look:point(0), self.sound_after_anim_start)
		self.state = state_standing
		self:update()
		return
	end

	local pt_chosen_idx, num_equal_pts = choose_look_point(self.patrol_look, self.path_look_info, search_for)
	--printf("_bp [%s]: pt_chosen_idx = %s", self.object:name(), utils.to_str(pt_chosen_idx))
	if pt_chosen_idx then
		local suggested_anim_set = self.path_look_info[pt_chosen_idx]["a"]
		if suggested_anim_set then
			self.cur_state_standing = xr_logic.pick_section_from_condlist(db.actor, self.object, suggested_anim_set)
		else
			self.cur_state_standing = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_standing)
		end

		local suggested_wait_time = self.path_look_info[pt_chosen_idx]["t"]
		if suggested_wait_time then
			if suggested_wait_time == '*' then
				self.pt_wait_time = nil -- -1
			else
				local tm = tonumber(suggested_wait_time)
				tm = tm and tm > 0 and tm or 0
				self.pt_wait_time = tm
			end
		else
			self.pt_wait_time = default_wait_time
		end

		local retv = self.path_look_info[pt_chosen_idx]["ret"]
		if retv then
			self.retval_after_rotation = tonumber(retv)
		else
			self.retval_after_rotation = nil
		end

		local look_pos = self.patrol_look:point(pt_chosen_idx)
		self.last_look_index = pt_chosen_idx
		self:update_standing_state(look_pos, self.sound_after_anim_start)

		self.state = state_standing

		--' Сразу же стартовать update, не ждать execute. Тогда, если мы уже смотрим
		--' в нужную сторону - не будет паузы в несколько миллисекунд на поворот.
		self:update()
	else
		self.cur_state_standing = xr_logic.pick_section_from_condlist(db.actor, self.object, self.default_state_standing)
		self:update_standing_state(self.patrol_look:point(0), self.sound_after_anim_start)
		self.state = state_standing
		self:update()
	end
end
