<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend IsCProject="false" IsPhysical="false" AppName="engine" Platform="DotNet" FileWrittenByProductVersion="2023.1.0.27">
  <OutputDir KeepXmlFiles="False">.\_CppDependOut</OutputDir>
  <Projects>
    <Name>.\engine.sln??Mixed|x64</Name>
  </Projects>
  <FrameworkProjects />
  <Dirs />
  <Excludes />
  <ZipSourceFiles>False</ZipSourceFiles>
  <Report Kind="0" SectionsEnabled="131071" XslPath="" Flags="261120" />
  <BuildComparisonSetting ProjectMode="DontCompare" BuildMode="NDaysAgoAnalysisResult" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="30" />
  <BaselineInUISetting ProjectMode="DontCompare" BuildMode="NDaysAgoAnalysisResult" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="30" />
  <CoverageFiles CoverageDir="" UncoverableAttribute="" />
  <UMLFiles UMLSections="511" />
  <Plugins Plugin="true" Vera="true" Modernize="true" CLangArgs="-checks=*,-android-*,-boost-*,-google-*,-fuchsia-*,-mpi-*,-objc-*">
    <LoadedPlugins />
  </Plugins>
  <ProjectParserSettings ParseIncludes="false" ParserKind="clang" QmakeFilePath="" TIPath="" ReneseasPath="" ArmPath="" ParserNbCores="0" ParserNbErrors="0" ParserTimeOut="10" />
  <TrendMetrics UseCustomLog="False" LogRecurrence="1" LogLabel="2" UseCustomDir="False" CustomDir="">
    <Chart Name="Lines of Code" ShowInReport="True">
      <Serie MetricName="# Lines of Code" MetricUnit="Loc" Color="#FF00BFFF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Lines of Code (NotMyCode)" MetricUnit="Loc" Color="#FFA9A9A9" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Lines of Comments" MetricUnit="Lines" Color="#FF008000" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violated" ShowInReport="True">
      <Serie MetricName="# Rules" MetricUnit="Rules" Color="#FF66CDAA" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Rules Violated" MetricUnit="Rules" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violated" MetricUnit="Rules" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violations" ShowInReport="True">
      <Serie MetricName="# Rules Violations" MetricUnit="Violations" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violations" MetricUnit="Violations" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Max" ShowInReport="True">
      <Serie MetricName="Max Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max Cyclomatic Complexity for Types" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # Lines of Code for Methods (JustMyCode)" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # of Methods for Types" MetricUnit="Methods" Color="#FF32CD32" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Average" ShowInReport="True">
      <Serie MetricName="Average Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average Cyclomatic Complexity for Types" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Lines of Code for Methods" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Methods for Types" MetricUnit="Methods" Color="#FF32CD32" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Third-Party Usage" ShowInReport="True">
      <Serie MetricName="# Third-Party Types Used" MetricUnit="Types" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Methods Used" MetricUnit="Methods" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Projects Used" MetricUnit="Projects" Color="#FF646464" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Namespaces Used" MetricUnit="Namespaces" Color="#FF32CD32" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Fields Used" MetricUnit="Fields" Color="#FFFFD700" ChartType="Line" ScaleExp="1" />
    </Chart>
  </TrendMetrics>
  <HistoricAnalysisResult PersistRecurrence="1" UseCustomDir="False" CustomDir="" />
  <SourceFileRebasing FromPath="" ToPath="" />
  <PathVariables />
  <RuleFiles />
  <ProjectRules AreActive="True" />
  <ProjectDebtSettings DebtSettingsStorage="0" SettingsFilePath="">
    <DebtSettings>
      <DebtFactor>1</DebtFactor>
      <AnnualInterestFactor>1</AnnualInterestFactor>
      <DebtDefault>0</DebtDefault>
      <AnnualInterestDefault>0</AnnualInterestDefault>
      <DebtStringFormat>$ManDay$</DebtStringFormat>
      <MoneyPerManHour>750</MoneyPerManHour>
      <Currency>RUB</Currency>
      <CurrencyLocation>After</CurrencyLocation>
      <EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode>18</EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode>
      <NumberOfWorkDayPerYear>230</NumberOfWorkDayPerYear>
      <NumberOfWorkHourPerDay>8</NumberOfWorkHourPerDay>
      <A2B_RatingThreshold>5</A2B_RatingThreshold>
      <B2C_RatingThreshold>10</B2C_RatingThreshold>
      <C2D_RatingThreshold>20</C2D_RatingThreshold>
      <D2E_RatingThreshold>50</D2E_RatingThreshold>
      <Info2Minor_SeverityThreshold>1200000000</Info2Minor_SeverityThreshold>
      <Minor2Major_SeverityThreshold>12000000000</Minor2Major_SeverityThreshold>
      <Major2Critical_SeverityThreshold>72000000000</Major2Critical_SeverityThreshold>
      <Critical2Blocker_SeverityThreshold>360000000000</Critical2Blocker_SeverityThreshold>
    </DebtSettings>
  </ProjectDebtSettings>
  <Queries>
    <Group Name="Quality Gates" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Quality Gates Evolution</Name>
from qg in QualityGates
let qgBaseline = qg.OlderVersion()
let relyOnDiff = qgBaseline == null
let evolution = relyOnDiff ? (TrendIcon?)null : 
                // When a quality gate relies on diff between now and baseline
                // it is not executed against the baseline
                qg.ValueDiff() == 0d ?
                TrendIcon.Constant :
                (qg.ValueDiff() > 0 ? 
                  ( qg.MoreIsBad ?  TrendIcon.RedUp: TrendIcon.GreenUp) :
                  (!qg.MoreIsBad ?  TrendIcon.RedDown: TrendIcon.GreenDown))
select new { qg, 
   Evolution      =  evolution,

   BaselineStatus =  relyOnDiff? (QualityGateStatus?) null : qgBaseline.Status,
   Status         =  qg.Status,

   BaselineValue  =  relyOnDiff? (null) : qgBaseline.ValueString,
   Value          =  qg.ValueString, 
}
 
// <Description>
// Show quality gates evolution between baseline and now.
//
// When a quality gate relies on diff between now and baseline (like *New Debt since Baseline*)
// it is not executed against the baseline and as a consequence its evolution is not available.
//
// Double-click a quality gate for editing.
// </Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Code Coverage" Unit="%" />
failif value < 70%
warnif value < 80%
codeBase.PercentageCoverage

//<Description>
// Code coverage is a measure used to describe the degree to which the source code of a program 
// is tested by a particular test suite. A program with high code coverage, measured as a percentage, 
// has had more of its source code executed during testing which suggests it has a lower chance of 
// containing undetected software bugs compared to a program with low code coverage.
//
// Code coverage is certainly the most important quality code metric. But coverage is not enough
// the team needs to ensure that results are checked at test-time. These checks can be done both 
// in test code, and in application code through assertions. The important part is that a test
// must fail explicitely when a check gets unvalidated during the test execution.
//
// This quality gate define a warn threshold (70%) and a fail threshold (80%). These are 
// indicative thresholds and in practice the more the better. To achieve high coverage and 
// low risk, make sure that new and refactored classes gets 100% covered by tests and that
// the application and test code contains as many checks/assertions as possible.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Coverage on New Code" Unit="%" />
failif value < 70%
warnif value < 80%
let newMethods = Application.Methods.Where(m => m.WasAdded() && m.NbLinesOfCode > 0)
let locCovered = newMethods.Sum(m => m.NbLinesOfCodeCovered)
let loc = newMethods.Sum(m => m.NbLinesOfCode)
select 100d * locCovered / loc

//<Description>
// *New Code* is defined as methods added since the baseline.
//
// To achieve high code coverage it is essential that new code gets properly
// tested and covered by tests. It is advised that all non-UI new classes gets
// 100% covered.
//
// Typically 90% of a class is easy to cover by tests and 10% is hard to reach 
// through tests. It means that this 10% remaining is not easily testable, which 
// means it is not well designed, which often means that this code is especially 
// **error-prone**. This is the reason why it is important to reach 100% coverage
// for a class, to make sure that potentially *error-prone* code gets tested.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Coverage on Refactored Code" Unit="%" />
failif value < 70%
warnif value < 80%
let newMethods = Application.Methods.Where(m => m.CodeWasChanged() && m.NbLinesOfCode > 0)
let locCovered = newMethods.Sum(m => m.NbLinesOfCodeCovered)
let loc = newMethods.Sum(m => m.NbLinesOfCode)
select 100d * locCovered / loc

//<Description>
// *Refactored Code* is defined as methods where *code was changed* since the baseline.
//
// Comment changes and formatting changes are not considerd as refactoring.
//
// To achieve high code coverage it is essential that refactored code gets properly
// tested and covered by tests. It is advised that when refactoring a class
// or a method, it is important to also write tests to make sure it gets 100% covered.
//
// Typically 90% of a class is easy to cover by tests and 10% is hard to reach 
// through tests. It means that this 10% remaining is not easily testable, which 
// means it is not well designed, which often means that this code is especially 
// **error-prone**. This is the reason why it is important to reach 100% coverage
// for a class, to make sure that potentially *error-prone* code gets tested.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Blocker Issues" Unit="issues" />
failif count > 0 issues
from i in Issues
where i.Severity == Severity.Blocker
select new { i, i.Severity, i.Debt, i.AnnualInterest }

//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// CppDepend Project Properties > Issue and Debt.
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Critical Issues" Unit="issues" />
failif count > 10 issues
warnif count > 0 issues

from i in Issues
where i.Severity == Severity.Critical
select new { i, i.Severity, i.Debt, i.AnnualInterest }

//<Description>
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worst it must 
// be fixed during the next iterations. 
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// CppDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Blocker / Critical / High Issues" Unit="issues" />
failif count > 0 issues
from i in Issues
where i.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High) &&  
      // Count both the new issues and the issues that became at least Critical
      (i.WasAdded() || i.OlderVersion().Severity < Severity.High)
select new { i, i.Severity, i.Debt, i.AnnualInterest }


//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed 
// during the next iterations. 
//
// An issue with a severity level **High** should be fixed quickly, but can wait until 
// the next scheduled interval.
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// CppDepend Project Properties > Issue and Debt.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Critical Rules Violated" Unit="rules" />
failif count > 0 rules
from r in Rules where r.IsCritical && r.IsViolated()
select new { r, issues = r.Issues() }

//<Description>
// The concept of critical rule is useful to pinpoint certain rules that 
// should not be violated.
//
// A rule can be made critical just by checking the *Critical button* in the
// rule edition control and then saving the rule.
//
// This quality gate fails if any critical rule gets any violations.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this quality gate count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Debt" Unit="%" />
failif value > 30%
warnif value > 20%
let timeToDev = codeBase.EffortToDevelop()
let debt = Issues.Sum(i => i.Debt)
select 100d * debt.ToManDay() / timeToDev.ToManDay()

// <Description>
// % Debt total is defined as a percentage on:
//
// • the estimated total effort to develop the code base
//
// • and the the estimated total time to fix all issues (the Debt)
//
// Estimated total effort to develop the code base is inferred from 
// # lines of code of the code base and from the 
// *Estimated number of man-dat to develop 1000 logicial lines of code*
// setting found in CppDepend Project Properties > Issue and Debt.
//
// Debt documentation: http://cppdepend.com/Doc_TechnicalDebt#Debt
//
// This quality gates fails if the estimated debt is more than 30%
// of the estimated effort to develop the code base, and warns if the 
// estimated debt is more than 20% of the estimated effort to develop 
// the code base
// </Description>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Debt" Unit="man-days" />
failif value > 50 man-days
warnif value > 30 man-days
Issues.Sum(i => i.Debt).ToManDay()

//<Description>
// This Quality Gate is disabled per default because the fail and warn 
// thresholds of unacceptable Debt in man-days can only depend on the 
// project size, number of developers and overall context.
//
// However you can refer to the default Quality Gate **Percentage Debt**.
//
// The Debt is defined as the sum of estimated effort to fix all issues.
// Debt documentation: http://cppdepend.com/Doc_TechnicalDebt#Debt
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Debt since Baseline" Unit="man-days" />
failif value > 2 man-days
warnif value > 0 man-days
let debt = Issues.Sum(i => i.Debt)
let debtInBaseline = IssuesInBaseline.Sum(i => i.Debt)
select (debt - debtInBaseline).ToManDay()


//<Description>
// This Quality Gate fails if the estimated effort to fix new or worsened
// issues (what is called the *New Debt since Baseline*) is higher
// than 2 man-days.
//
// This Quality Gate warns if this estimated effort is positive.
//
// Debt documentation: http://cppdepend.com/Doc_TechnicalDebt#Debt
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Debt Rating per Namespace" Unit="namespaces" />
failif count > 0 namespaces

from n in Application.Namespaces
where n.DebtRating() != null &&
      n.DebtRating().Value.EqualsAny(DebtRating.E, DebtRating.D)
select new { 
   n, 
   debtRating = n.DebtRating(),
   debtRatio = n.DebtRatio(),  // % of debt from which DebtRating is inferred
   devTimeInManDay = n.EffortToDevelop().ToDebt(), 
   debtInManDay = n.AllDebt(),
   issues = n.AllIssues() 
}

// <Description>
// Forbid namespaces with a poor Debt Rating equals to **E** or **D**.
//
// The **Debt Rating** for a code element is estimated by the value of the **Debt Ratio**
// and from the various rating thresholds defined in this project *Debt Settings*. 
//
// The **Debt Ratio** of a code element is a percentage of **Debt Amount** (in floating man-days) 
// compared to the **estimated effort to develop the code element** (also in floating man-days).
//
// The **estimated effort to develop the code element** is inferred from the code elements
// number of lines of code, and from the project *Debt Settings* parameters 
// *estimated number of man-days to develop 1000* **logical lines of code**.
//
// The **logical lines of code** corresponds to the number of debug breakpoints in a method
// and doesn't depend on code formatting nor comments.
//
// The Quality Gate can be modified to match projects, types or methods
// with a poor Debt Rating, instead of matching namespaces.
// </Description>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Annual Interest" Unit="man-days" />
failif value > 50 man-days
warnif value > 30 man-days
Issues.Sum(i => i.AnnualInterest).ToManDay()


//<Description>
// This Quality Gate is disabled per default because the fail and warn 
// thresholds of unacceptable Annual-Interest in man-days can only depend
// on the project size, number of developers and overall context.
//
// However you can refer to the default Quality Gate 
// **New Annual Interest since Baseline**.
//
// The Annual-Interest is defined as the sum of estimated annual cost
// in man-days, to leave all issues unfixed.
//
// Each rule can either provide a formula to compute the Annual-Interest 
// per issue, or assign a **Severity** level for each issue. Some thresholds
// defined in *Project Properties > Issue and Debt > Annual Interest* are
// used to infer an Annual-Interest value from a Severity level.
// Annual Interest documentation: http://cppdepend.com/Doc_TechnicalDebt#AnnualInterest
//</Description>


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Annual Interest since Baseline" Unit="man-days" />
failif value > 2 man-days
warnif value > 0 man-days
let ai = Issues.Sum(i => i.AnnualInterest)
let aiInBaseline = IssuesInBaseline.Sum(i => i.AnnualInterest)
select (ai - aiInBaseline).ToManDay()

//<Description>
// This Quality Gate fails if the estimated annual cost to leave all issues
// unfixed, increased from more than 2 man-days since the baseline.
//
// This Quality Gate warns if this estimated annual cost is positive.
//
// This estimated annual cost is named the **Annual-Interest**.
//
// Each rule can either provide a formula to compute the Annual-Interest 
// per issue, or assign a **Severity** level for each issue. Some thresholds
// defined in *Project Properties > Issue and Debt > Annual Interest* are
// used to infer an Annual-Interest value from a Severity level.
// Annual Interest documentation: http://cppdepend.com/Doc_TechnicalDebt#AnnualInterest
//</Description>

]]></Query>
    </Group>
    <Group Name="Code Smells" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid types too big</Name>
warnif count > 0 from t in JustMyCode.Types where 

   // First filter on type to optimize 
   t.NbLinesOfCode > 500 
  

   // What matters is the # lines of code in JustMyCode
   let locJustMyCode = t.MethodsAndContructors.Where(m => JustMyCode.Contains(m)).Sum(m => m.NbLinesOfCode)
   where locJustMyCode > 500

  

   orderby locJustMyCode descending
select new { 
   t, 
   locJustMyCode, 
   t.Methods, 
   t.Fields,
   
   Debt = (locJustMyCode.Linear(200, 1, 2000, 10)).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 300 loc
   // to interest for severity critical for 2000 loc
   AnnualInterest = (locJustMyCode.Linear(
                          200,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                          2000, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches types with more than 500 lines of code.
// **Only lines of code in JustMyCode methods are taken account.**
//
// Types where *NbLinesOfCode > 500* are extremely complex 
// to develop and maintain.
// See the definition of the NbLinesOfCode metric here 
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
//
// Maybe you are facing the **God Class** phenomenon:
// A **God Class** is a class that controls way too many other classes 
// in the system and has grown beyond all logic to become 
// *The Class That Does Everything*.
//</Description>

//<HowToFix>
// Types with many lines of code
// should be split in a group of smaller types.
// 
// To refactor a *God Class* you'll need patience, 
// and you might even need to recreate everything from scratch.
// Here are a few refactoring advices:
//
// • The logic in the *God Class* must be splitted in smaller classes.
// These smaller classes can eventually become private classes nested
// in the original *God Class*, whose instances objects become 
// composed of instances of smaller nested classes.
//
// • Smaller classes partitioning should be driven by the multiple
// responsibilities handled by the *God Class*. To identify these 
// responsibilities it often helps to look for subsets of methods
// strongly coupled with subsets of fields.
//
// • If the *God Class* contains way more logic than states, a good 
// option can be to define one or several static classes that 
// contains no static field but only pure static methods. A pure static 
// method is a function that computes a result only from inputs
// parameters, it doesn't read nor assign any static or instance field.
// The main advantage of pure static methods is that they are easily
// testable.
// 
// • Try to maintain the interface of the *God Class* at first 
// and delegate calls to the new extracted classes. 
// In the end the *God Class* should be a pure facade without its own logic.
// Then you can keep it for convenience or throw it away and 
// start to use the new classes only.
//
// • Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a 200 lines of code type,
// up to 10 hours for a type with 2.000 or more lines of code.
//
// In Debt and Interest computation, this rule takes account of the fact 
// that static types with no mutable fields are just a collection of 
// static methods that can be easily splitted and moved from one type 
// to another.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with too many methods</Name>
warnif count > 0 from t in JustMyCode.Types 

  // Optimization: Fast discard of non-relevant types 
  where t.Methods.Count() > 30

  // Don't match these methods
  let methods = t.Methods.Where(
       m => !(m.IsGeneratedByCompiler ||
              m.IsConstructor ))

  where methods.Count() > 30 
  orderby methods.Count() descending

  

select new { 
   t, 
   nbMethods = methods.Count(),
   instanceMethods = methods.Where(m => !m.IsStatic), 
   staticMethods = methods.Where(m => m.IsStatic),

   t.NbLinesOfCode,

   Debt = (methods.Count().Linear(20, 1, 200, 10)).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 30 methods
   // to interest for severity critical for 200 methods
   AnnualInterest = (methods.Count().Linear(
                              20,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                              200, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches types with more than 30 methods. 
// Such type might be hard to understand and maintain.
//
// Notice that methods like constructors or property 
// and event accessors are not taken account.
//
// Having many methods for a type might be a symptom
// of too many responsibilities implemented.
//
// Maybe you are facing the **God Class** phenomenon:
// A **God Class** is a class that controls way too many other classes 
// in the system and has grown beyond all logic to become 
// *The Class That Does Everything*.
//</Description>

//<HowToFix>
// To refactor properly a *God Class* please read *HowToFix advices* 
// from the default rule **Types to Big**.
////
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a type with 20 methods,
// up to 10 hours for a type with 200 or more methods.
//
// In Debt and Interest computation, this rule takes account of the fact 
// that static types with no mutable fields are just a collection of 
// static methods that can be easily splitted and moved from one type 
// to another.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with too many fields</Name>
warnif count > 0 from t in JustMyCode.Types 

  // Optimization: Fast discard of non-relevant types 
  where !t.IsEnumeration &&
         t.Fields.Count() > 25
        
  // Count instance fields and non-constant static fields
  let fields = t.Fields.Where(f =>
          !f.IsGeneratedByCompiler &&        
          !(f.IsStatic ) &&
           JustMyCode.Contains(f) )

  where fields.Count() > 25
 
  let methodsAssigningFields = fields.SelectMany(f => f.MethodsAssigningMe)

  orderby fields.Count() descending
select new { 
   t, 
   instanceFields = fields.Where(f => !f.IsStatic),
   staticFields = fields.Where(f => f.IsStatic),
methodsAssigningFields ,   

   Debt = fields.Count().Linear(15, 1, 200, 10).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 30 methods
   // to interest for severity critical for 200 methods
   AnnualInterest = fields.Count().Linear(15,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                          200, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches types with more than 25 fields. 
// Such type might be hard to understand and maintain.
//
// Notice that constant fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//
// Having many fields for a type might be a symptom
// of too many responsibilities implemented.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to group subsets of fields into smaller types
// and dispatch the logic implemented into the methods 
// into these smaller types.
//
// More refactoring advices can be found in the default rule 
// **Types to Big**, *HowToFix* section.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a type with 15 fields,
// to up to 10 hours for a type with 200 or more fields. 
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid methods too big, too complex</Name>
warnif count > 0 from m in JustMyCode.Methods where 
    (m.NbLinesOfCode > 100 ||
   m.CyclomaticComplexity > 30)

  let complexityScore = m.NbLinesOfCode/2 + m.CyclomaticComplexity 

  orderby complexityScore descending,
          m.CyclomaticComplexity descending
select new { 
   m, 
   m.NbLinesOfCode,
   m.CyclomaticComplexity, 
   complexityScore,

   Debt = complexityScore.Linear(30, 40,    400, 8*60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity minor 
   // to interest for severity major
   AnnualInterest = complexityScore .Linear(30,     Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                            200, 2*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule matches methods where 
// (*NbLinesOfCode* > 100 
// or *CyclomaticComplexity* > 30
// Such method is typically hard to understand and maintain.
//
// Maybe you are facing the **God Method** phenomenon.
// A "God Method" is a method that does way too many processes in the system 
// and has grown beyond all logic to become *The Method That Does Everything*.
// When need for new processes increases suddenly some programmers realize: 
// why should I create a new method for each processe if I can only add an *if*.
//
// See the definition of the *CyclomaticComplexity* metric here:
// http://www.cppdepend.com/Metrics.aspx#CC
//
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies from 40 minutes to 8 hours, linearly from a weighted complexity score.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid methods with too many parameters</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbParameters >= 10
  orderby m.NbParameters descending
select new { 
   m, 
   m.NbParameters,

   Debt = m.NbParameters.Linear(7, 1,  40, 6).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for 7 parameters
   // to interest for severity Critical for 40 parameters
   AnnualInterest = m.NbParameters.Linear(7,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                          40, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches methods with more than 10 parameters.
// Such method is painful to call and might degrade performance.
// See the definition of the *NbParameters* metric here: 
// http://www.cppdepend.com/Metrics.aspx#NbParameters
//</Description>

//<HowToFix>
// More properties/fields can be added to the declaring type to 
// handle numerous states. An alternative is to provide 
// a class or a structure dedicated to handle arguments passing.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a method with 7 parameters,
// up to 6 hours for a methods with 40 or more parameters.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with too many local variables</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbVariables > 25 
  orderby m.NbVariables descending
select new { 
   m, 
   m.NbVariables,

   Debt = m.NbVariables.Linear(15, 1,   80, 6).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for 15 variables
   // to interest for severity Critical for 80 variables
   AnnualInterest = m.NbVariables.Linear(15,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                         80,  Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()

}

//<Description>
// This rule matches methods with more than 25 variables.
//
// Methods where *NbVariables > 15* are hard to understand and maintain.
// Methods where *NbVariables > 25* are extremely complex and must be refactored. 
//
// See the definition of the *Nbvariables* metric here: 
// http://www.cppdepend.com/Metrics.aspx#Nbvariables
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 10 minutes for a method with 15 variables,
// up to 2 hours for a methods with 80 or more variables.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with too many overloads</Name>
warnif count > 0 from m in JustMyCode.Methods where 
   m.NbOverloads >= 10 && 
  !m.IsOperator // Don't report operator overload
  orderby m.NbOverloads descending
let overloads = 
 m.IsConstructor ? m.ParentType.Constructors :
                   m.ParentType.Methods.Where(m1 => m1.SimpleName == m.SimpleName)
select new { 
   m, 
   overloads,
   Debt = 2.ToMinutes().ToDebt(),
   Severity = Severity.Medium
}

//<Description>
// Method overloading is the ability to create multiple methods of the same name 
// with different implementations, and various set of parameters.
//
// This rule matches sets of methods with 10 overloads or more.
//
// Such method set might be a problem to maintain 
// and provokes coupling higher than necessary.
//
// See the definition of the *NbOverloads* metric here 
// http://www.cppdepend.com/Metrics.aspx#NbOverloads
//</Description>

//<HowToFix>
// Typically the *too many overloads* phenomenon appears when an algorithm
// takes a various set of in-parameters. Each overload is presented as 
// a facility to provide a various set of in-parameters.
// The *too many overloads* phenomenon can also be a consequence of the usage
// of the **visitor design pattern** http://en.wikipedia.org/wiki/Visitor_pattern 
// since a method named *Visit()* must be provided for each sub type.
// In such situation there is no need for fix.
//
// Sometime *too many overloads* phenomenon is not the symptom of a problem,
// for example when a *numeric to something conversion* method applies to 
// all numeric and nullable numeric types.
//
// The estimated Debt, which means the effort to fix such issue,
// is of 2 minutes per method overload.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with poor cohesion</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.LCOM > 0.8  && 
  t.NbFields > 10 && 
  t.NbMethods >10 

  let poorCohesionScore = 1/(1.01 - t.LCOM)
  orderby poorCohesionScore descending

  select new { 
   t, 
   t.LCOM, 
   t.NbMethods, 
   t.NbFields,
   poorCohesionScore,

   Debt = poorCohesionScore.Linear(5, 5, 50, 4*60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for low poorCohesionScore
   // to 4 times interest for severity Major for high poorCohesionScore
   AnnualInterest = poorCohesionScore.Linear(5,     Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                             50, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is based on the *LCOM code metric*,
// LCOM stands for **Lack Of Cohesion of Methods**.
// See the definition of the LCOM metric here 
// http://www.cppdepend.com/Metrics.aspx#LCOM
//
// The LCOM metric measures the fact that most methods are using most fields.
// A class is considered utterly cohesive (which is good)
// if all its methods use all its instance fields.
//
// Only types with enough methods and fields are taken account to avoid bias.
// The LCOM takes its values in the range [0-1].
//
// This rule matches types with LCOM higher than 0.8.
// Such value generally pinpoints a **poorly cohesive class**.
//</Description>

//<HowToFix>
// To refactor a poorly cohesive type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller and more cohesive types
// that together, implement the same logic.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 5 minutes for a type with a low poorCohesionScore,
// up to 4 hours for a type with high poorCohesionScore.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="Code Smells Regression" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all types added should respect basic quality principles</Name>
warnif count > 0 from t in JustMyCode.Types where

// Only match types added since Baseline.
// Uncomment this line to match also refactored types since Baseline.
// (t.WasAdded() || t.CodeWasChanged()) &&
   t.WasAdded() &&

// Eliminate interfaces, enumerations or types only with constant fields
// by making sure we are matching type with code.
t.NbLinesOfCode > 10 &&

// Optimization: Fast discard of non-relevant types 
(t.Fields.Count() > 20 || t.Methods.Count() > 20)
      
// Count instance fields and non-constant static fields
let fields = t.Fields.Where(f =>!(f.IsStatic))

// Don't match these methods
let methods = t.Methods.Where(
   m => !(m.IsConstructor  ||
          m.IsGeneratedByCompiler ))
  
where 

// Low Quality types     Metrics' definitions are available here:
//     http://www.cppdepend.com/Metrics.aspx#MetricsOnTypes
(  // Types with too many methods
   fields.Count() > 30 ||

   methods.Count() > 30 ||
               
   // Complex Types that use more than 50 other types
   t.NbTypesUsed > 50
)
select new { 
   t, 
   t.NbLinesOfCode, 

   instanceMethods = methods.Where(m => !m.IsStatic), 
   staticMethods = methods.Where(m => m.IsStatic),
  
   instanceFields = fields.Where(f => !f.IsStatic),
   staticFields = fields.Where(f => f.IsStatic),
  
   t.TypesUsed,

   // Constant Debt estimation, since for such type rules in category "Code Quality" 
   // accurately estimate the Debt.
   Debt     = 10.ToMinutes().ToDebt(),

   // The Severity is higher for new types than for refactored types 
   AnnualInterest= (t.WasAdded() ? 3 : 1) *
                    Severity.High.AnnualInterestThreshold()
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on types added since baseline.
//
// This rule can be easily modified to also match types refactored since baseline,
// that don't satisfy all quality criterions.
//
// Types matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it has too many methods,
// it has too many fields,
// or is using too many types.
// Any of these criterions is often a symptom of a type with too many responsibilities.
//
// Notice that to count methods and fields, methods like constructors 
// or property and event accessors are not taken account.
// Notice that constants fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller types
// that together, implement the same logic.
//
// Issues of this rule have a constant 10 minutes Debt, because the Debt,
// which means the effort to fix such issue, is already estimated for issues
// of rules in the category **Code Quality**.
//
// However issues of this rule have a **High** severity, with even more 
// interests for issues on new types since baseline, because the proper time 
// to increase the quality of these types is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all types added should be 100% covered by tests</Name>
warnif count > 0 from t in JustMyCode.Types where

// Only match types added since Baseline.
// Uncomment this line to match also refactored types since Baseline.
// (t.WasAdded() || t.CodeWasChanged()) &&
   t.WasAdded() &&

  // …that are not 100% covered by tests
  t.PercentageCoverage < 100

  let methodsCulprit = t.Methods.Where(m => m.PercentageCoverage < 100)

select new { 
   t, 
   t.PercentageCoverage, 
   methodsCulprit,
   t.NbLinesOfCode,

   // Constant Debt estimation, since for such type rules in category "Coverage" 
   // accurately estimate the untested code Debt.
   Debt     = 10.ToMinutes().ToDebt(),

   // The Severity is higher for new types than for refactored types 
   AnnualInterest= (t.WasAdded() ? 3 : 1) *
                    Severity.High.AnnualInterestThreshold()
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on types added since baseline.
//
// This rule can be easily modified to also match types refactored since baseline,
// that are not 100% covered by tests.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering 10% of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, typically teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the 10% remaining code
// because **most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// In this context, this rule warns when a type added or refactored since the baseline,
// is not fully covered by tests.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//
// Issues of this rule have a constant 10 minutes Debt, because the Debt,
// which means the effort to write tests for the culprit type, is already 
// estimated for issues in the category **Code Coverage**. 
//
// However issues of this rule have a **High** severity, with even more 
// interests for issues on new types since baseline, because the proper time 
// to write tests for these types is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all methods added should respect basic quality principles</Name>
warnif count > 0 from m in JustMyCode.Methods where

// Only match methods added since Baseline.
// Uncomment this line to match also refactored methods since Baseline.
// (m.WasAdded() || m.CodeWasChanged()) &&
   m.WasAdded() &&
 
// Low Quality methods// Metrics' definitions
(  m.NbLinesOfCode > 100 ||          // http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
   m.CyclomaticComplexity > 30 ||   // http://www.cppdepend.com/Metrics.aspx#CC
   m.NbParameters > 10 ||            // http://www.cppdepend.com/Metrics.aspx#NbParameters
   m.NbVariables > 20 ||             // http://www.cppdepend.com/Metrics.aspx#NbVariables
   m.NbOverloads > 10 )
select new { 
   m, 
   m.NbLinesOfCode,
   m.CyclomaticComplexity, 
   m.NbParameters, 
   m.NbVariables, 
   m.NbOverloads, // http://www.cppdepend.com/Metrics.aspx#NbOverloads

   // Constant Debt estimation, since for such method rules in category "Code Quality" 
   // accurately estimate the Debt.
   Debt     = 5.ToMinutes().ToDebt(),

   // The Severity is higher for new methods than for refactored methods
   AnnualInterest= (m.WasAdded() ? 3 : 1) *
                   Severity.High.AnnualInterestThreshold()
}  

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule can be easily modified to also match methods refactored since baseline,
// that don't satisfy all quality criterions.
//
// Methods matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it is too large (too many *lines of code*), 
// too complex (too many *if*, *switch case*, loops…)
// has too many variables, too many parameters
// or has too many overloads.
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// Issues of this rule have a constant 5 minutes Debt, because the Debt,
// which means the effort to fix such issue, is already estimated for issues
// of rules in the category **Code Quality**.
// 
// However issues of this rule have a **High** severity, with even more 
// interests for issues on new methods since baseline, because the proper time 
// to increase the quality of these methods is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid decreasing code coverage by tests of types</Name>
warnif count > 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() && t.CoverageDataAvailable && t.OlderVersion().CoverageDataAvailable
let locDiff = (int)t.NbLinesOfCode.Value - (int)t.OlderVersion().NbLinesOfCode.Value
where locDiff >= 0
let uncoveredLoc  = (int)t.NbLinesOfCodeNotCovered.Value - ((int)t.OlderVersion().NbLinesOfCodeNotCovered.Value + locDiff)
where uncoveredLoc > 0

orderby uncoveredLoc descending

select new { 
   t,
   OldCoverage = t.OlderVersion().PercentageCoverage,
   NewCoverage = t.PercentageCoverage,
   OldLoc = t.OlderVersion().NbLinesOfCode,
   NewLoc = t.NbLinesOfCode,
   uncoveredLoc,

   Debt = uncoveredLoc.Linear(1, 15,  100, 3*60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Major for one line of code that is not covered by tests anymore
   // to interest for severity Critical for 50 lines of code that are not covered by tests anymore
   AnnualInterest = uncoveredLoc.Linear(1,    Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                        50, 2*Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
   

}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// This rule warns when the number of lines of a type covered by tests
// decreased since the baseline. In case the type faced some refactoring
// since the baseline, this loss in coverage is estimated only for types 
// with more lines of code, where # lines of code covered now is lower
// than # lines of code covered in baseline + the extra number of
// lines of code.
//
// Such situation can mean that some tests have been removed
// but more often, this means that the type has been modified,
// and that changes haven't been covered properly by tests.
//
// To visualize changes in code, right-click a matched type and select:
//
// • Compare older and newer versions of source file
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover changes in matched types
// not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//
// The estimated Debt, which means the effort to cover by test 
// code that used to be covered, varies linearly 15 minutes to 3 hours,
// depending on the number of lines of code that are not covered by tests anymore.
//
// Severity of issues of this rule varies from **High** to **Critical** 
// depending on the number of lines of code that are not covered by tests anymore.
// Because the loss in code coverage happened since the baseline,
// the severity is high because it is important to focus on these issues 
// **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making complex methods even more complex</Name>
warnif count > 0 

let complexityScoreProc = new Func<IMethod, double>(m => 
    (m.CyclomaticComplexity ).Value)

from m in JustMyCode.Methods where
 !m.IsAbstract &&
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() &&
  m.OlderVersion().CyclomaticComplexity > 6 

let complexityScore = complexityScoreProc(m)
let oldComplexityScore = complexityScoreProc(m.OlderVersion())
where complexityScore > oldComplexityScore 

let complexityScoreDiff = complexityScoreProc(m) - complexityScoreProc(m.OlderVersion())
orderby complexityScoreDiff descending

select new { 
   m,
   oldComplexityScore ,
   complexityScore ,
   diff= complexityScoreDiff,

   Debt = complexityScoreDiff.Linear(1, 15,   50, 60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for a tiny complexity increment
   // to interest for severity critical for 2000 loc
   AnnualInterest = complexityScoreDiff.Linear(1,     Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                               50, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// The method complexity is measured through the code metric
// *Cyclomatic Complexity* defined here:
// http://www.cppdepend.com/Metrics.aspx#CC
//
// This rule warns when a method already complex
// (i.e with *Cyclomatic Complexity* higher than 6)
// become even more complex since the baseline.
//
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 15 to 60 minutes depending on the extra complexity added.
//
// Issues of this rule have a **High** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making large methods even larger</Name>

warnif count > 0 
from m in JustMyCode.Methods where
 !m.IsAbstract &&

 // Eliminate constructors from match, since they get larger
 // as soons as some fields initialization are added.
 !m.IsConstructor &&
 

  // Filter just here for optimization
  m.NbLinesOfCode > 100 &&

  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() 

let oldLoc = m.OlderVersion().NbLinesOfCode
where oldLoc > 15 && m.NbLinesOfCode > oldLoc

let diff = m.NbLinesOfCode - oldLoc
where diff > 0
orderby diff descending 

select new { 
   m,
   oldLoc,
   newLoc = m.NbLinesOfCode,
   diff,

   Debt = diff.Linear(1, 10,   100, 60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for a tiny complexity increment
   // to interest for severity critical for 2000 loc
   AnnualInterest = diff .Linear(1,      Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                 100, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns when a method already large
// (i.e with more than 15 lines of code)
// become even larger since the baseline.
//
// The method size is measured through the code metric
// *# Lines of Code* defined here:
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//</Description>

//<HowToFix>
// Usually too big methods should be split in smaller methods.
//
// But long methods with no branch conditions, that typically initialize some data,
// are not necessarily a problem to maintain, and might not need refactoring.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 5 to 20 minutes depending 
// on the number of lines of code added.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 10 to 60 minutes depending on the extra complexity added.
//
// Issues of this rule have a **High** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid adding methods to a type that already had many methods</Name>

warnif count > 0 

// Don't count constructors and methods generated by the compiler!
let getMethodsProc = new Func<IType, IList<IMethod>>(
   t => t.Methods.Where(m =>
      !m.IsConstructor  && 
      !m.IsGeneratedByCompiler).ToArray()) 


from t in JustMyCode.Types where
  
  t.NbMethods > 30 &&   // Just here for optimization

  t.IsPresentInBothBuilds()

  // Optimization: fast discard of non-relevant types
  where t.OlderVersion().NbMethods > 30

  let oldMethods = getMethodsProc(t.OlderVersion())
  where oldMethods.Count > 30

  let newMethods = getMethodsProc(t)
  where newMethods.Count > oldMethods.Count

  let addedMethods = newMethods.Where(m => m.WasAdded())
  let removedMethods = oldMethods.Where(m => m.WasRemoved())

  orderby addedMethods.Count() descending

select new { 
   t,
   nbOldMethods = oldMethods.Count,
   nbNewMethods = newMethods.Count,
   addedMethods,
   removedMethods,

   Debt           = (10*addedMethods.Count()).ToMinutes().ToDebt(),
   AnnualInterest =     addedMethods.Count().Linear(
          1,       Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
          100,  4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// Types where number of methods is greater than 15 
// might be hard to understand and maintain.
//
// This rule lists types that already had more than 15 methods
// at the baseline time, and for which new methods have been added.
//
// Having many methods for a type might be a symptom
// of too many responsibilities implemented.
//
// Notice that constructors and methods generated by the compiler 
// are not taken account.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller types
// that together, implement the same logic.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 10 minutes per method added.
//
// Issues of this rule have a **High** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid adding instance fields to a type that already had many instance fields</Name>

warnif count > 0 

let getFieldsProc = new Func<IType, IList<IField>>(
   t => t.Fields.Where(f => 
          !f.IsGeneratedByCompiler &&
          !f.IsStatic).ToArray()) 


from t in JustMyCode.Types where
  
 !t.IsEnumeration &&
  t.IsPresentInBothBuilds()

  // Optimization: fast discard of non-relevant types
  where t.OlderVersion().NbFields > 15

  let oldFields = getFieldsProc(t.OlderVersion())
  where oldFields.Count > 15

  let newFields = getFieldsProc(t)
  where newFields.Count > oldFields.Count

  let addedFields = newFields.Where(f => f.WasAdded())
  let removedFields = oldFields.Where(f => f.WasRemoved())

  orderby addedFields.Count() descending

select new { 
   t,
   nbOldFields = oldFields.Count,
   nbNewFields = newFields.Count,
   addedFields,
   removedFields,

   Debt           = (10*addedFields.Count()).ToMinutes().ToDebt(),
   AnnualInterest =     addedFields.Count().Linear(
          1,       Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
          100,  4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()

}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// Types where number of fields is greater than 15 
// might be hard to understand and maintain.
//
// This rule lists types that already had more than 15 fields
// at the baseline time, and for which new fields have been added.
//
// Having many fields for a type might be a symptom
// of too many responsibilities implemented.
//
// Notice that *constants* fields and *static-readonly* fields are not taken account.
// Enumerations types are not taken account also.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to group subsets of fields into smaller types
// and dispatch the logic implemented into the methods 
// into these smaller types.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 10 minutes per field added.
//
// Issues of this rule have a **High** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid transforming an immutable type into a mutable one</Name>

warnif count > 0
from t in Application.Types where
   t.CodeWasChanged() &&
   t.OlderVersion().IsImmutable &&
  !t.IsImmutable 

let culpritFields = t.InstanceFields.Where(f => f.IsImmutable)
select new {
   t, 
   culpritFields,
   Debt = (10 + 10*culpritFields.Count()).ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// A type is considered as *immutable* if its instance fields
// cannot be modified once an instance has been built by a constructor.
//
// Being immutable has several fortunate consequences for a type.
// For example its instance objects can be used concurrently 
// from several threads without the need to synchronize accesses.
//
// Hence users of such type often rely on the fact that the type is immutable.
// If an immutable type becomes mutable, there are chances that this will break 
// users code.
//
// This is why this rule warns about such immutable type that become mutable.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 2 minutes per instance field that became mutable.
//</Description>

//<HowToFix>
// If being immutable is an important property for a matched type,
// then the code must be refactored to preserve immutability.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 10 minutes plus 10 minutes per instance fields of
// the matched type that is now mutable.
//
// Issues of this rule have a **High** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="Object Oriented Design" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Base class should not use derivatives</Name>
warnif count > 0 
from baseClass in JustMyCode.Types
where baseClass.IsClass && baseClass.NbChildren > 0 // <-- for optimization!
let derivedClassesUsed = baseClass.DerivedTypes.UsedBy(baseClass)
where derivedClassesUsed.Count() > 0

let derivedClassesMemberUsed = derivedClassesUsed.SelectMany(c => c.Members).UsedBy(baseClass)
orderby derivedClassesMemberUsed.Count() descending

select new { 
   baseClass, 
   derivedClassesUsed,
   derivedClassesMemberUsed,

   Debt = 3*(derivedClassesUsed.Count()+derivedClassesMemberUsed.Count()).ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// In *Object-Oriented Programming*, the **open/closed principle** states:
// *software entities (components, classes, methods, etc.) should be open 
// for extension, but closed for modification*. 
// http://en.wikipedia.org/wiki/Open/closed_principle
//
// Hence a base class should be designed properly to make it easy to derive from,
// this is *extension*. But creating a new derived class, or modifying an
// existing one, shouldn't provoke any *modification* in the base class.
// And if a base class is using some derivative classes somehow, there
// are good chances that such *modification* will be needed.
//
// Extending the base class is not anymore a simple operation,
// this is not good design.
//</Description>

//<HowToFix>
// Understand the need for using derivatives, 
// then imagine a new design, and then refactor.
//
// Typically an algorithm in the base class needs to access something 
// from derived classes. You can try to encapsulate this access behind 
// an abstract or a virtual method.
//
// If you see in the base class some conditions on *typeof(DerivedClass)*
// not only *urgent refactoring* is needed. Such condition can easily 
// be replaced through an abstract or a virtual method.
//
// Sometime you'll see a base class that creates instance of some derived classes.
// In such situation, certainly using the *factory method pattern* 
// http://en.wikipedia.org/wiki/Factory_method_pattern
// or the *abstract factory pattern* 
// http://en.wikipedia.org/wiki/Abstract_factory_pattern
// will improve the design.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 3 minutes per derived class used by the base class +
// 3 minutes per member of a derived class used by the base class.
//</HowToFix>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Class shouldn't be too deep in inheritance tree</Name>
warnif count > 0 from t in JustMyCode.Types 
where t.IsClass
let baseClasses = t.BaseClasses.ExceptThirdParty()
where baseClasses.Count() >= 3
orderby baseClasses.Count() descending

select new { 
   t, 
   baseClasses, 
   // The metric value DepthOfInheritance takes account
   // of third-party base classessee its definition here:
   // http://www.ndepend.com/Metrics#DIT
   t.DepthOfInheritance,
   Debt = (baseClasses.Count() -2)*3.ToMinutes().ToDebt(),
   Severity = Severity.Medium
} 

//<Description>
// This rule warns about classes having 3 or more base classes.
// Notice that third-party base classes are not counted
// because this rule is about your code design, not 
// third-party libraries consumed design.
//
// *In theory*, there is nothing wrong having a *long inheritance chain*,
// if the modelization has been well thought out,
// if each base class is a well-designed refinement of the domain.
//
// *In practice*, modeling properly a domain demands a lot of effort
// and experience and more often than not, a *long inheritance chain*
// is a sign of confused design, that will be hard to work with and maintain.
//</Description>

//<HowToFix>
// In *Object-Oriented Programming*, a well-known motto is
// **Favor Composition over Inheritance**.
//
// This is because *inheritance* comes with pitfalls.
// In general, the implementation of a derived class is very bound up with 
// the base class implementation. Also a base class exposes implementation
// details to its derived classes, that's why it's often said that 
// inheritance breaks encapsulation. 
//
// On the other hands, *Composition* favors binding with interfaces
// over binding with implementations. Hence, not only the encapsulation
// is preserved, but the design is clearer, because interfaces make it explicit
// and less coupled.
//
// Hence, to break a *long inheritance chain*, *Composition* is often
// a powerful way to enhance the design of the refactored underlying logic.
//
// You can also read: 
// http://en.wikipedia.org/wiki/Composition_over_inheritance and
// http://stackoverflow.com/questions/49002/prefer-composition-over-inheritance
//
// The estimated Debt, which means the effort to fix such issue,
// depends linearly upon the depth of inheritance.
//</HowToFix>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Constructor should not call a virtual methods</Name>
warnif count > 0

from t in Application.Types where 
   t.IsClass &&
  !t.IsGeneratedByCompiler 

from ctor in t.Constructors 
let virtualMethodsCalled = 
   from mCalled in ctor.MethodsCalled
   where mCalled.IsVirtual && 
         // Only take care of just-my-code virtual methods called
         JustMyCode.Contains(mCalled) &&
         (  mCalled.ParentType == t ||
           (t.DeriveFrom(mCalled.ParentType))
         )
   select mCalled
where virtualMethodsCalled.Count() > 0

select new { 
   ctor , 
   virtualMethodsCalled, 
   // If there is no derived type, it might be 
   // an opportunity to mark t as sealed.
   t.DerivedTypes,
   Debt = ((virtualMethodsCalled.Count())*6).ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule matches constructors of a non-sealed class that call one or
// several virtual methods.
//
// When an object written in C++ is constructed, what happens is that constructors 
// run in order from the base class to the most derived class.
//
// Also objects do not change type as they are constructed, but start out as 
// the most derived type, with the method table being for the most derived type. 
// This means that virtual method calls always run on the most derived type,
// even when calls are made from the constructor.
//
// When you combine these two facts you are left with the problem that if you 
// make a virtual method call in a constructor, and it is not the most derived 
// type in its inheritance hierarchy, then it will be called on a class whose 
// constructor has not been run, and therefore may not be in a suitable state 
// to have that method called.
//
// Hence this situation makes the class *fragile to derive from*.
//</Description>

//<HowToFix>
// Violations reported can be solved by re-designing object initialisation
// or by declaring the parent class as *sealed*, if possible.
//</HowToFix>


    ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't assign static fields from instance methods</Name>
warnif count > 0
from f in Application.Fields where 
  f.IsStatic &&
 !f.IsGeneratedByCompiler 
let assignedBy = f.MethodsAssigningMe.Where(m => !m.IsStatic)
where assignedBy .Count() > 0
select new { 
   f, 
   assignedBy,
   Debt = 5.ToMinutes().ToDebt(),
   Severity = Severity.Medium
}
     
//<Description>
// Assigning static fields from instance methods leads to
// poorly maintainable and non-thread-safe code.
//
// More discussion on the topic can be found here:
// http://codebetter.com/patricksmacchia/2011/05/04/back-to-basics-usage-of-static-members/
//</Description>

//<HowToFix>
// If the *static* field is just assigned once in the program
// lifetime, make sure to declare it as *readonly* and assign 
// it inline, or from the static constructor.
//
// In *Object-Oriented-Programming* the natural artifact 
// to hold states that can be modified is **instance fields**.
//
// Hence to fix violations of this rule, make sure to
// hold assignable states through *instance* fields, not
// through *static* fields.
//</HowToFix>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid Abstract Classes with too many methods</Name>
warnif count > 0 

from t in Application.Types
where t.IsAbstract && t.NbMethods >= 10 // Optimization  First threshold
let methodsCount = t.Methods.Count() 
where methodsCount >= 10
orderby methodsCount descending
select new {  
   t, 
   t.Methods,
   Debt = (methodsCount.Linear(10, 20,   100, 7*60)).ToMinutes().ToDebt(),
   // The annual interest varies linearly from interest for severity Minor for an interface with 10 methods
   // to interest for severity Critical for an interface with 100 methods and more
   AnnualInterest = (methodsCount.Linear(
                       10,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes,
                       100, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes))
                     .ToMinutes().ToAnnualInterest()
}


//<Description>
// This rule matches abstract classes with more than 10 methods.
// Abstract clases are abstractions and are meant to simplify the code structure.
// An interface should represent a single responsibility.
// Making an interface too large, too complex, necessarily means
// that the interface has too many responsibilities.
//
// A property with getter or setter or both count as one method.
// An event count as one method.
//</Description>

//<HowToFix>
// Typically to fix such issue, the interface must be refactored
// in a grape of smaller *single-responsibility* interfaces.
//
// A classic example is a *ISession* large interface, responsible
// for holding states, run commands and offer various accesses
// and facilities.
//
// The classic problem for a large public interface is that it has
// many clients that consume it. As a consequence splitting it in 
// smaller interfaces has an important impact and it is not always
// feasible.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 20 minutes for an interface with 10 methods,
// up to 7 hours for an interface with 100 or more methods.
// The Debt is divided by two if the interface is not publicly
// visible, because in such situation only the current project is impacted
// by the refactoring.
//</HowToFix>


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Type should not have too many responsibilities</Name>
// Types using more than 8 different application namespaces 
// are considered as having too many responsabilities.
warnif count > 0 

from t in JustMyCode.Types 
let applicationTypesUsed = t.TypesUsed.ExceptThirdParty().ToList()
let applicationNamespacesUsed = applicationTypesUsed.ParentNamespaces().ToList()
where applicationNamespacesUsed.Count > 8

// Use an empiric formula to sort by degree of responsabilities
let responsabilitiesMetric = (10 * applicationNamespacesUsed.Count + applicationTypesUsed.Count)/10
orderby responsabilitiesMetric descending

select new { t, applicationNamespacesUsed, applicationTypesUsed, responsabilitiesMetric } 


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Nested types should not be visible</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.IsNested && 
 !t.IsGeneratedByCompiler &&
 !t.IsPrivate 
let typesUser = t.TypesUsingMe.Where(t1 => t1 != t.ParentType && t1.ParentType != t.ParentType)
select new { 
   t, 
   t.Visibility,
   typesUser,
   Debt = (2 + 4*typesUser.Count()).ToMinutes().ToDebt(),
   Severity = Severity.Medium
} 

//<Description>
// This rule warns about nested types not declared as private.
//
// A nested type is a type declared within the scope of another 
// type. Nested types are useful for encapsulating private 
// implementation details of the containing type. Used 
// for this purpose, nested types should not be externally visible.
//
// Do not use externally visible nested types for logical 
// grouping or to avoid name collisions; instead use namespaces.
//
// Nested types include the notion of member accessibility, 
// which some programmers do not understand clearly.
//
// Protected types can be used in subclasses and nested types 
// in advanced customization scenarios.
//</Description>

//<HowToFix>
// If you do not intend the nested type to be externally visible,
// change the type's accessibility. 
//
// Otherwise, remove the nested type from its parent and make it 
// *non-nested*.
//
// If the purpose of the nesting is to group some nested types, 
// use a namespace to create the hierarchy instead.
//
// The estimated Debt, which means the effort to fix such issue,
// is 2 minutes per nested type plus 4 minutes per outter type
// using such nesting type.
//</HowToFix>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects with poor cohesion (RelationalCohesion)</Name>
warnif count > 0 from a in Application.Projects 

// Build the types list on which we want to check cohesion
// This is the project 'a' type, minus enumeration
// and types generated by the compiler.
let types = a.ChildTypes.Where(
   t => !t.IsGeneratedByCompiler &&
        !t.IsEnumeration)
        // Absolutly need ToHashet() to have fast Intersect() calls below.
        .ToHashSetEx()

// Relational Cohesion metrics is relevant only if there are enough types
where types.LongCount()> 20

// R is the total number of relationship between types of the projects. 
let R = types.Sum(t => t.TypesUsed.Intersect(types).Count())

// Relational Cohesion formula
let relationalCohesion = (double)R / types.Count
where  
  
  (relationalCohesion  < 1.5 || 
   relationalCohesion  > 4.0)
select new { 
  a, 
  a.ChildTypes,
  relationalCohesion, 
  a.RelationalCohesion,
  Debt = 10.ToMinutes().ToDebt(),
  Severity = Severity.Low
}

//<Description>
// This rule computes the *Relational Cohesion* metric for
// the application projects, and warns about wrong values.
// 
// The *Relational Cohesion* for an project, is the total number 
// of relationship between types of the projects, divided 
// by the number of types. In other words it is the average
// number of types in the project used by a type in the project.
//
// As classes inside an project should be strongly related, 
// the cohesion should be high. On the other hand, a value 
// which is too high may indicate over-coupling. A good range 
// for *Relational Cohesion* is **1.5 to 4.0**.
//
// Notice that projects with less than 20 types are ignored.
//</Description>

//<HowToFix>
// Matches of this present rule might reveal either projects
// with specific coding constraints (like code generated that
// have particular structure) either issues in design.
//
// In the second case, large refactoring can be planned
// not to respect this rule in particular, but to increase
// the overall design and code maintainability.
//
// The severity of issues of this rule is **Low** because
// the code metric *Relational Cohesion* is an information 
// about the code structure state but **is not actionable**, 
// it doesn't tell precisely what to do obtain a better score.
//
// Fixing actionable issues of others **Architecture** and 
// **Code Quality** default rules will necessarily increase 
// the *Relational Cohesion* scores.
//</HowToFix>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects that don't satisfy the Abstractness/Instability principle</Name>
warnif count > 0 from a in Application.Projects 
  where a.NormDistFromMainSeq > 0.7
  orderby a.NormDistFromMainSeq descending
select new { 
   a,
   a.NormDistFromMainSeq,
   Debt = 10.ToMinutes().ToDebt(),
   Severity = Severity.Low
}

//<Description>
// The **Abstractness versus Instability Diagram** that is shown in the CppDepend 
// report helps to assess which projects are **potentially painful to maintain**
// (i.e concrete and stable) and which projects are **potentially useless** 
// (i.e abstract and instable).
//
// • **Abstractness**: If an project contains many abstract types 
// (i.e interfaces and abstract classes) and few concrete types, 
// it is considered as abstract.
//
// • **Stability**: An project is considered stable if its types 
// are used by a lot of types from other projects. In this context 
// stable means *painful to modify*.
//
// From these metrics, we define the *perpendicular normalized distance of
// an project from the idealized line* **A + I = 1** (called *main sequence*). 
// This metric is an indicator of the project's balance between abstractness 
// and stability. We precise that the word *normalized* means that the range 
// of values is [0.0 … 1.0].
//
// This rule warns about projects with a *normalized distance* greater than 
// than 0.7.
//
// This rules use the default code metric on project
// *Normalized Distance from the Main Sequence* explained here: 
// http://www.cppdepend.com/Metrics#DitFromMainSeq
//
// These concepts have been originally introduced by *Robert C. Martin*
// in 1994 in this paper: http://www.objectmentor.com/resources/articles/oodmetrc.pdf
//</Description>

//<HowToFix>
// Violations of this rule indicate projects with an improper 
// *abstractness / stability* balance.
//
// • Either the project is *potentially painful to maintain* (i.e is massively
// used and contains mostly concrete types). This can be fixed by creating 
// abstractions to avoid too high coupling with concrete implementations.
//
// • Either the project is *potentially useless* (i.e contains mostly
// abstractions and is not used enough). In such situation, the design
// must be reviewed to see if it can be enhanced.
//
// The severity of issues of this rule is **Low** because
// the *Abstractness/Instability principle* is an information 
// about the code structure state but **is not actionable**, 
// it doesn't tell precisely what to do obtain a better score.
//
// Fixing actionable issues of others **Architecture** and 
// **Code Quality** default rules will necessarily push 
// the *Abstractness/Instability principle* scores in the 
// right direction.
//</HowToFix>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Higher cohesion - lower coupling</Name>
// It is deemed as a good software architecture practice to clearly separate
// 'abstract' namespaces containing only abstractions (interfaces, enumerations, delegates)
// from other 'concrete' namespaces, that contains classes and structures.
//
// Typically, the more concrete namespaces rely on abstract namespaces *only*,
// the more Decoupled is the architecture, and the more Cohesive are 
// classes inside concrete namespaces.
//
// The following code query, define sets of abstract and concrete namespaces
// and shows for each concrete namespaces, which concrete and abstract namespaces are used.
// 
// This query can be adapted to a rule, depending on how much you want
// your code architecture being decoupled.
//

let abstractNamespaces = JustMyCode.Namespaces.Where(
     n => n.ChildTypes.Where(t => !t.IsInterface && !t.IsEnumeration ).Count() == 0
).ToHashSetEx()

let concreteNamespaces = JustMyCode.Namespaces.Except(abstractNamespaces).ToHashSetEx()

from n in concreteNamespaces
let namespacesUsed = n.NamespacesUsed.ExceptThirdParty()
let concreteNamespacesUsed = namespacesUsed.Except(abstractNamespaces)
let abstractNamespacesUsed = namespacesUsed.Except(concreteNamespaces)
select new { n, concreteNamespacesUsed , abstractNamespacesUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Constructors of abstract classes should be declared as protected or private</Name>
// Constructors of an abstract class can only be accessed from this class and derived class.
// Declaring such a constructor with another visibility level is useless and potentially misleading.

warnif count > 0
from t in Application.Types where 
  t.IsClass && 
  t.IsAbstract
let ctors = t.Constructors.Where(c => !c.IsProtected && !c.IsPrivate && !c.IsGeneratedByCompiler)
where ctors.Count() > 0
select new { t, ctors }

// Notice that if a constructor of an abstract class is declared as private,
// it can only be accessed from derived classes nested in the abstract class.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The class does not have a constructor.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="noConstructor" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Medium
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Class has a constructor with 1 argument that is not explicit.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" 
&& issue.Type=="noExplicitConstructor" && issue.RelatedMethod!=null && !issue.RelatedMethod.IsExplicitConstructor  
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Medium
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Value of pointer var, which points to allocated memory, is copied in copy constructor instead of allocating new memory.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="copyCtorPointerCopying" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Medium
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>class class does not have a copy constructor which is recommended since the class contains a pointer to allocated memory.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="noCopyConstructor" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Medium
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Member variable  is not initialized in the constructor.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uninitMemberVar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Member variable  is not assigned a value in classname::operator=.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="operatorEqVarError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unused private function: classname::funcname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedPrivateFunction" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Medium
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Using memfunc on class that contains a classname.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetClass" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Using memfunc on class that contains a reference.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetClassReference" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Using memset() on class which contains a floating point number.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetClassFloat" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory for class instance allocated with malloc(), but class provides constructors.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="mallocOnClassWarning" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory for class instance allocated with malloc(), but class contains a std::string.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="mallocOnClassError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>class::operator= should return class &.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="operatorEq" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Class Base which is inherited by class Derived does not have a virtual destructor.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="virtualDestructor" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Suspicious pointer subtraction. Did you intend to write ->?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="thisSubtraction" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>operator= should return reference to this instance.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="operatorEqRetRefThis" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>No return statement in non-void function causes undefined behavior.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="operatorEqMissingReturnStatement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>operator= should either return reference to this instance or be declared private and left unimplemented.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="operatorEqShouldBeLeftUnimplemented" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>operator= should check for assignment to self to avoid problems with dynamic memory.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="operatorEqToSelf" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Variable  is assigned in constructor body. Consider performing initialization in initialization list.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="useInitializationList" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Member variable  is initialized by itself.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="selfInitialization" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The class class defines member variable with name variable also defined in its parent class class.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplInheritedMember" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
    </Group>
    <Group Name="UML Design Validation" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Missing Types In Code</Name>
warnif count > 0 from issue in ImportedIssues 
where issue.ToolName=="UML Validation" && issue.Type=="MissingTypesInCode" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Moved Types In Code</Name>
warnif count > 0 from issue in ImportedIssues 
where issue.ToolName=="UML Validation" && issue.Type=="MovedTypesInCode" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Missing Types Inheritences In Code</Name>
warnif count > 0 from issue in ImportedIssues 
where issue.ToolName=="UML Validation" && issue.Type=="MissingInheritencesInCode" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Missing Methods In UML</Name>
warnif count > 0 from issue in ImportedIssues 
where issue.ToolName=="UML Validation" && issue.Type=="MissingMethodsInUML" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Missing Methods In Code</Name>
warnif count > 0 from issue in ImportedIssues 
where issue.ToolName=="UML Validation" && issue.Type=="MissingMethodsInCode" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Missing Fields In Code</Name>
warnif count > 0 from issue in ImportedIssues 
where issue.ToolName=="UML Validation" && issue.Type=="MissingFieldsInCode" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Missing Fields In UML</Name>
warnif count > 0 from issue in ImportedIssues 
where issue.ToolName=="UML Validation" && issue.Type=="MissingFieldsInUML" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Missing Associations In UML</Name>
warnif count > 0 from issue in ImportedIssues 
where issue.ToolName=="UML Validation" && issue.Type=="MissingAssociationsInUML" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Missing Associations In Code</Name>
warnif count > 0 from issue in ImportedIssues 
where issue.ToolName=="UML Validation" && issue.Type=="MissingAssociationsInCode" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fixed UML issues</Name>
from issue in 
codeBase.OlderVersion().Application.ImportedIssues
where issue.ToolName=="UML Validation" && Application.ImportedIssues.Where(f=>f.Description==issue .Description).Count()==0
select new { issue   }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Added UML issues</Name>
from issue in 
Application.ImportedIssues
where issue.ToolName=="UML Validation" && codeBase.OlderVersion().Application.ImportedIssues.Where(f=>f.Description==issue.Description).Count()==0
select new { issue  }]]></Query>
    </Group>
    <Group Name="Memory Management" Active="True" ShownInReport="False">
      <Group Name="Leaks" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Returning/dereferencing p after it is deallocated / released</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocret" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory pointed to by varname is freed twice.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="doubleFree" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Allocation with funcName, funcName doesnt release it.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="leakNoVarFunctionCall" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Return value of allocation function funcName is not stored.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="leakReturnValNotUsed" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible leak in public function. The pointer varname is not deallocated before it is allocated.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="publicAllocationError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Class class is unsafe, class::varname can leak by wrong usage.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unsafeClassCanLeak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory leak: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memleak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Resource leak: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="resourceLeak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Deallocating a deallocated pointer: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocDealloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dereferencing varname after it is deallocated / released</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="deallocuse" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The allocated size sz is not a multiple of the underlying types size.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="mismatchSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Mismatching allocation and deallocation: varname</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="mismatchAllocDealloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Common realloc mistake: varname nulled but not freed upon failure</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memleakOnRealloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      </Group>
      <Group Name="Null Pointer" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Null pointer dereference</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible null pointer dereference if the default parameter value is used: pointer</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointerDefaultArg" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Either the condition is redundant or there is possible null pointer dereference: pointer.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nullPointerRedundantCheck" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
      <Group Name="Auto Variables" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Address of local auto-variable assigned to a function parameter.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="autoVariables" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Address of an auto-variable returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnAddressOfAutoVariable" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Pointer to local array variable returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnLocalVariable" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Reference to auto variable returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnReference" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Reference to temporary returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnTempReference" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Deallocation of an auto-variable results in undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="autovarInvalidDeallocation" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Address of function parameter parameter returned.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="returnAddressOfFunctionParameter" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Assignment of function parameter has no effect outside the function.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessAssignmentArg" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Assignment of function parameter has no effect outside the function. Did you forget dereferencing it?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessAssignmentPtrArg" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
      <Group Name="Bounds Checking" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array array[2] index array[1][1] out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer is accessed out of bounds: buffer</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="bufferAccessOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dangerous usage of strncat - 3rd parameter is the maximum number of characters to append.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="strncatUsage" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>index is out of bounds: Supplied size 2 is larger than actual size 1.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="outOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The size argument is given as a char constant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="sizeArgumentAsChar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array index -1 is out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="negativeIndex" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer overrun possible for long command line arguments.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="insecureCmdLineArgs" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Undefined behaviour, pointer arithmetic  is out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array index index is used before limits check.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexThenCheck" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible buffer overflow if strlen(source) is larger than or equal to sizeof(destination).</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="possibleBufferAccessOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The array array is too small, the function function expects a bigger one.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="argumentSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Memory allocation size is negative.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="negativeMemoryAllocationSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Declaration of array  with negative size is undefined behaviour</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="negativeArraySize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Array x[10] accessed at index 20, which is out of bounds. Otherwise condition y==20 is redundant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="arrayIndexOutOfBoundsCond" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
    </Group>
    <Group Name="STL" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Invalid iterator: iterator</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidIterator1" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Same iterator is used with different containers container1 and container2.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="iterators" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Iterators of different containers are used together.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="mismatchingContainers" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Invalid iterator iter used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="eraseDereference" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>When i==foo.size(), foo[i] is out of bounds.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stlOutOfBounds" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>After push_back|push_front|insert(), the iterator iterator may be invalid.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidIterator2" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Invalid pointer pointer after push_back().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidPointer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dangerous comparison using operator< on iterator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stlBoundaries" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Suspicious condition. The result of find() is an iterator, but it is not properly checked.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stlIfFind" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Inefficient usage of string::find() in condition; string::compare() would be faster.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stlIfStrFind" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dangerous usage of c_str(). The value returned by c_str() is invalid after this call.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stlcstr" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Returning the result of c_str() in a function that returns std::string is slow and redundant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stlcstrReturn" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Passing the result of c_str() to a function that takes std::string as argument no. 0 is slow and redundant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stlcstrParam" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible inefficient checking for list emptiness.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stlSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Missing bounds check for extra iterator increment in loop.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="StlMissingComparison" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant checking of STL container element existence before removing it.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantIfRemove" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>You can randomly lose access to pointers if you store auto_ptr pointers in an STL container.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="useAutoPointerContainer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Object pointed by an auto_ptr is destroyed using operator delete. You should not use auto_ptr for pointers obtained with operator new[].</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="useAutoPointerArray" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Object pointed by an auto_ptr is destroyed using operator delete. You should not use auto_ptr for pointers obtained with function malloc.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="useAutoPointerMalloc" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>It is inefficient to call str.find(str) as it always returns 0.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessCallsCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>It is inefficient to swap a object with itself by calling str.swap(str)</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessCallsSwap" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Ineffective call of function substr because it returns a copy of the object. Use operator= instead.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessCallsSubstr" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Ineffective call of function empty(). Did you intend to call clear() instead?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessCallsEmpty" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Return value of std::remove() ignored. Elements remain in container.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="uselessCallsRemove" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible dereference of an invalid iterator: i</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="derefInvalidIterator" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
    </Group>
    <Group Name="Primitive Types Usage" Active="True" ShownInReport="False">
      <Group Name="Boolean" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Boolean value assigned to pointer.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="assignBoolToPointer" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Boolean value assigned to floating point variable.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="assignBoolToFloat" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of a function returning boolean value using relational (<, >, <= or >=) operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonOfFuncReturningBoolError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of two functions returning boolean value using relational (<, >, <= or >=) operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonOfTwoFuncsReturningBoolError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of a variable having boolean value using relational (<, >, <= or >=) operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonOfBoolWithBoolError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Incrementing a variable of type bool with postfix operator++ is deprecated by the C++ Standard. You should assign it the value true instead.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="incrementboolean" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of a boolean expression with an integer other than 0 or 1.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="compareBoolExpressionWithInt" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Converting pointer arithmetic result to bool. The bool is always true unless there is undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerArithBool" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      </Group>
      <Group Name="String" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Modifying string literal directly or indirectly is undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stringLiteralWrite" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Undefined behavior: Variable varname is used as parameter and destination in s[n]printf().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="sprintfOverlappingData" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unusual pointer arithmetic. A value of type char is added to a string literal.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="strPlusChar" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>String literal Hello World doesnt match length argument for substr().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="incorrectStringCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>String literal compared with variable foo. Did you intend to use strcmp() instead?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="literalWithCharPtrCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Char literal compared with pointer foo. Did you intend to dereference it?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="charLiteralWithCharPtrCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Conversion of string literal Hello World to bool always evaluates to true.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="incorrectStringBooleanError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unnecessary comparison of static strings.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="staticStringCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of identical string variables.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="stringCompare" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
      <Group Name="Type" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Shifting 32-bit value by 64 bits is undefined behaviour</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="shiftTooManyBits" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Signed integer overflow for expression .</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="integerOverflow" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Suspicious code: sign conversion of var in calculation, even though var can have a negative value</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="signConversion" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>int result is assigned to long variable. If the variable is long to avoid loss of information, then you have loss of information.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="truncLongCastAssignment" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>int result is returned as long value. If the return value is long to avoid loss of information, then you have loss of information.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="truncLongCastReturn" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      </Group>
    </Group>
    <Group Name="IO usage" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>scanf is deprecated: This function or variable may be unsafe. Consider using scanf_s instead.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Clang" && issue.Type=="warn_deprecated_message" &&  issue.Description.Contains("'scanf'")
 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Invalid usage of output stream: << std::cout.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="coutCerrMisusage" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>fflush() called on input stream stdin may result in undefined behaviour on non-linux systems.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="fflushOnInputStream" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Read and write operations without a call to a positioning function (fseek, fsetpos or rewind) or fflush in between result in undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="IOWithoutPositioning" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Read operation on a file that was opened only for writing.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="readWriteOnlyFile" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Write operation on a file that was opened only for reading.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="writeReadOnlyFile" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Used file that is not opened.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="useClosedFile" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Repositioning operation performed on a file opened in append mode has no effect.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="seekOnAppendedFile" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>scanf() without field width limits can crash with huge input data.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidscanf" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>printf format string requires 3 parameters but only 2 are given.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="wrongPrintfScanfArgNum" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>I in format string (no. 1) is a length modifier and cannot be used without a conversion specifier.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidLengthModifierError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Width 5 given in format string (no. 10) is larger than destination buffer [0], use %-1s to prevent overflowing it.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidScanfFormatWidth" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>printf: referencing parameter 2 while 1 arguments given</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="wrongPrintfScanfParameterPositionError" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
    </Group>
    <Group Name="64-bit portability" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Assigning a pointer to an integer is not portable.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="AssignmentAddressToInteger" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Assigning an integer to a pointer is not portable.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="AssignmentIntegerToAddress" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Returning an integer in a function with pointer return type is not portable.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="CastIntegerToAddressAtReturn" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Returning an address value in a function with integer return type is not portable.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="CastAddressToIntegerAtReturn" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
    </Group>
    <Group Name="Misc" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Either the condition is redundant or there is division by zero at line 0.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="zerodivcond" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Instance of varname object is destroyed immediately.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedScopedObject" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Casting between float* and double* which have an incompatible binary data representation.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="invalidPointerCast" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Shifting a negative value is undefined behaviour</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="shiftNegative" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer varname must have size of 2 integers if used as parameter of pipe().</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="wrongPipeParameterSize" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Race condition: non-interlocked access after InterlockedDecrement(). Use InterlockedDecrement() return value instead.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="raceAfterInterlockedDecrement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer var is being written before its old content has been used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantCopy" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Variable var is reassigned a value before the old one has been used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantAssignment" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comparison of two identical variables with isless(varName,varName) always evaluates to false.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="comparisonFunctionIsAlwaysTrueOrFalse" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Storing func_name() return value in char variable and then comparing with EOF.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="checkCastIntToCharAndBack" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Function parameter parametername should be passed by reference.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="passedByValue" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant code: Found a statement that begins with type constant.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="constStatement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Signed char type used as array index.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="signedCharArrayIndex" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>char type used as array index.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unknownSignCharArrayIndex" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>When using char variables in bit operations, sign extension can generate unexpected results.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="charBitOp" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The scope of the variable varname can be reduced.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="variableScope" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Variable var is reassigned a value before the old one has been used. break; missing?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantAssignInSwitch" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Buffer var is being written before its old content has been used. break; missing?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantCopyInSwitch" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant assignment of varname to itself.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="selfAssignment" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>memset() called to fill 0 bytes.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetZeroBytes" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The 2nd memset() argument varname is a float, its representation is implementation defined.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetFloat" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The 2nd memset() argument varname doesnt fit into an unsigned char.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="memsetValueOutOfRange" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Clarify calculation precedence for + and ?.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="clarifyCalculation" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Ineffective statement similar to *A++;. Did you intend to write (*A)++;?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="clarifyStatement" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Same expression on both sides of &&.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplicateExpression" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Same expression in both branches of ternary operator.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplicateExpressionTernary" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Consecutive return, break, continue, goto or throw statements are unnecessary.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="duplicateBreak" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Statements following return, break, continue, goto or throw will never be executed.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unreachableCode" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Checking if unsigned variable varname is less than zero.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unsignedLessThanZero" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unsigned variable varname cant be negative so it is unnecessary to test it.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unsignedPositive" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A pointer can not be negative so it is either pointless or an error to check if it is.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerLessThanZero" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A pointer can not be negative so it is either pointless or an error to check if it is not.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="pointerPositive" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Passing NULL after the last typed argument to a variadic function leads to undefined behaviour.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="varFuncNullUB" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Using NaN/Inf in a computation.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="nanInArithmeticExpression" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Comma is used in return statement. The comma can easily be misread as a ;.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="commaSeparatedReturn" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Redundant pointer operation on varname - its already a pointer.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="redundantPointerOp" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Label  is not used. Should this be a case of the enclosing switch()?</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedLabelSwitch" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Label  is not used.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unusedLabel" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Expression x = x++; depends on order of evaluation of side effects</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="unknownEvaluationOrder" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 10.ToMinutes().ToDebt(),
     Severity =Severity.High
    }
                ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Prefer prefix ++/-- operators for non-primitive types.</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="CppCheck" && issue.Type=="postfixOperator" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     Debt = 2.ToMinutes().ToDebt(),
     Severity =Severity.Low
    }
                ]]></Query>
    </Group>
    <Group Name="Vera++ Rules" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Source files should not use the '\r' (CR) character</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="F001" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>File names should be well-formed</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="F002" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>No trailing whitespace</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="L001" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't use tab characters</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="L002" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>No leading and no trailing empty lines</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="L003" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Line cannot be too long</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="L004" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>There should not be too many consecutive empty lines</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="L005" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Source file should not be too long</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="L006" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>One-line comments should not have forced continuation</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T001" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Reserved names should not be used for preprocessor macros</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T002" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Some keywords should be followed by a single space</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T003" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Some keywords should be immediately followed by a colon</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T004" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Keywords break and continue should be immediately followed by a semicolon</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T005" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
   
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Keywords return and throw should be immediately followed by a semicolon or a single space</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T006" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Semicolons should not be isolated by spaces or comments from the rest of the code</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T007" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Keywords catch, for, if, switch and while should be followed by a single space</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T008" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Comma should not be preceded by whitespace, but should be followed by one</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T009" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
     
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Identifiers should not be composed of 'l' and 'O' characters only</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T010" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
   
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Curly brackets from the same pair should be either in the same line or in the same column</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T011" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Negation operator should not be used in its short form</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T012" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
   
     Severity =Severity.Low
    }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Source files should contain the copyright notice</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T013" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
   
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>HTML links in comments and string literals should be correct</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T015" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Calls to min/max should be protected against accidental macro substitution</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T016" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Calls Unnamed namespaces are not allowed in header files</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T017" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Using namespace is not allowed in header files</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T018" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
    
     Severity =Severity.Low
    }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Control structures should have complete curly-braced block of code</Name>
warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Vera++" && issue.Type=="T019" 
select new { issue, issue.FilePath, Line = issue.BeginLine ,
  
     Severity =Severity.Low
    }]]></Query>
    </Group>
    <Group Name="API Breaking Changes" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Types</Name>
// This rule warns if a publicly visible type is 
// not publicly visible anymore or if it has been removed.
// Such type can break the code of your clients.

warnif count > 0 from t in codeBase.OlderVersion().Application.Types
where t.IsPublic && 

     // The type has been removed and its parent project hasn't been removed ...
     ( (t.WasRemoved() && !t.ParentProject.WasRemoved()) ||

     // ... or the type is not publicly visible anymore
       !t.WasRemoved() && !t.NewerVersion().IsPublic)

select new { t,
             NewVisibility = (t.WasRemoved() ? " " : t.NewerVersion().Visibility.ToString()) }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Methods</Name>
warnif count > 0 from m in codeBase.OlderVersion().Application.Methods
where m.IsPublic && m.IsExported && 

     // The method has been removed, it was not tagged as obsolete
     // and its parent type hasn't been removed …
     ( ( m.WasRemoved() && 
        !m.ParentType.WasRemoved())

        // … or the method is not publicly visible anymore
     || (!m.WasRemoved() && !m.NewerVersion().IsPublic) 

        // … or the method return type has changed
     || (!m.WasRemoved() && m.ReturnType != null && m.NewerVersion().ReturnType != null
                         && m.ReturnType.FullName != m.NewerVersion().ReturnType.FullName)        
      )

select new { 
   m,
   NewVisibility = 
      (m.WasRemoved() ? " " : 
       m.NewerVersion().Visibility.ToString()),
   }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Fields</Name>
// This rule warns if a publicly visible field is 
// not publicly visible anymore or if it has been removed.
// Such field can break the code of your clients.

warnif count > 0 from f in codeBase.OlderVersion().Application.Fields
where f.IsPublic &&

     // The field has been removed and its parent type hasn't been removed ...
     ( (f.WasRemoved() && !f.ParentType.WasRemoved()) ||

     // ... or the field is not publicly visible anymore
       !f.WasRemoved() && !f.NewerVersion().IsPublic)

select new { f,
             NewVisibility = (f.WasRemoved() ? " " : f.NewerVersion().Visibility.ToString()) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Interfaces and Abstract Classes</Name>
// This rule warns if a publicly visible interface or abstract class 
// has been changed and contains new abstract methods or 
// if some abstract methods have been removed.
// This can break the code of clients 
// that implement such interface or derive from such abstract class.

warnif count > 0 from tNewer in Application.Types where 
 (tNewer.IsInterface || tNewer.IsClass && tNewer.IsAbstract) && 
  tNewer.IsPublic && 
  tNewer.IsPresentInBothBuilds()

let tOlder = tNewer.OlderVersion() where tOlder.IsPublic

let methodsRemoved = tOlder.Methods.Where(m => m.IsAbstract && m.WasRemoved())
let methodsAdded = tNewer.Methods.Where(m => m.IsAbstract && m.WasAdded())

where methodsAdded.Count() > 0 || methodsRemoved.Count() > 0
select new { tNewer, methodsAdded, methodsRemoved }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid transforming immutable types into mutable types</Name>

// Immutability is a strong property on a type.
// Breaking immutability can result in serious problem for an algorithm consummer
// that has been written taking account of the type immutability.

// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file


warnif count > 0 
from t in Application.Types where
  t.IsPresentInBothBuilds() &&
 
 !t.IsImmutable && 
  t.OlderVersion().IsImmutable

let mutableFields = from f in t.InstanceFields where !f.IsImmutable select f

select new { t, mutableFields }

]]></Query>
    </Group>
    <Group Name="Code Diff Summary" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Projects</Name>
from a in Application.Projects where a.WasAdded()
select new { a, a.NbLinesOfCode }

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects removed</Name>
from a in codeBase.OlderVersion().Application.Projects where a.WasRemoved()
select new { a, a.NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects where code was changed</Name>
from a in Application.Projects where a.CodeWasChanged()
select new { a, a.NbLinesOfCode, 
             oldNbLinesOfCode = a.OlderVersion().NbLinesOfCode ,
             delta = (int) a.NbLinesOfCode - a.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New namespaces</Name>
from n in Application.Namespaces where 
 !n.ParentProject.WasAdded() &&
  n.WasAdded()
select new { n, n.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces removed</Name>
from n in codeBase.OlderVersion().Application.Namespaces where 
 !n.ParentProject.WasRemoved() &&
  n.WasRemoved()
select new { n, n.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces where code was changed</Name>
from n in Application.Namespaces where n.CodeWasChanged()
select new { n, n.NbLinesOfCode, 
             oldNbLinesOfCode = n.OlderVersion().NbLinesOfCode ,
             delta = (int) n.NbLinesOfCode - n.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New types</Name>
from t in Application.Types where 
 !t.ParentNamespace.WasAdded() &&
  t.WasAdded()
select new { t, t.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types removed</Name>
from t in codeBase.OlderVersion().Application.Types where 
 !t.ParentNamespace.WasRemoved() &&
  t.WasRemoved()
select new { t, t.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types where code was changed</Name>
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file


from t in Application.Types where t.CodeWasChanged() 
//select new { t, t.NbLinesOfCode }
select new { t, t.NbLinesOfCode, 
             oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
             delta = (int?) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode } 
/*from t in Application.Types where t.CodeWasChanged() && t.IsPresentInBothBuild
select new { t, t.NbLinesOfCode, 
             oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
             delta = (int) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode }*/]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Heuristic to find types moved from one namespace or project to another</Name>
let typesRemoved = codeBase.OlderVersion().Types.Where(t => t.WasRemoved())
let typesAdded = Types.Where(t => t.WasAdded())

from tMoved in typesAdded.Join(
   typesRemoved,
   t => t.Name,
   t => t.Name,
   (tNewer, tOlder) => new { tNewer, 
                             OlderParentNamespace = tOlder.ParentNamespace,
                             OlderParentproject = tOlder.ParentProject  } ) 
select tMoved]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types directly using one or several types changed</Name>
let typesChanged = Application.Types.Where(t => t.CodeWasChanged()).ToHashSetEx()

from t in JustMyCode.Types.UsingAny(typesChanged) where
  !t.CodeWasChanged() && 
  !t.WasAdded()
let typesChangedUsed = t.TypesUsed.Intersect(typesChanged) 
select new { t, typesChangedUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types indirectly using one or several types changed</Name>
let typesChanged = Application.Types.Where(t => t.CodeWasChanged()).ToHashSetEx()

// 'depth' represents a code metric defined on types using
// directly or indirectly any type where code was changed.
let depth = JustMyCode.Types.DepthOfIsUsingAny(typesChanged) 

from t in depth.DefinitionDomain where
  !t.CodeWasChanged() && 
  !t.WasAdded()

let typesChangedDirectlyUsed = t.TypesUsed.Intersect(typesChanged) 
let depthOfUsingTypesChanged = depth[t]
orderby depthOfUsingTypesChanged 

select new { t, depthOfUsingTypesChanged, typesChangedDirectlyUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New methods</Name>
from m in Application.Methods where 
 !m.ParentType.WasAdded() &&
  m.WasAdded()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods removed</Name>
from m in codeBase.OlderVersion().Application.Methods where 
 !m.ParentType.WasRemoved() &&
  m.WasRemoved()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where code was changed</Name>
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file


from m in Application.Methods where m.CodeWasChanged()
select new { m, m.NbLinesOfCode, 
             oldNbLinesOfCode = m.OlderVersion().NbLinesOfCode ,
             delta = (int?) m.NbLinesOfCode - m.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSetEx()

from m in JustMyCode.Methods.UsingAny(methodsChanged ) where
  !m.CodeWasChanged() && 
  !m.WasAdded()
let methodsChangedCalled = m.MethodsCalled.Intersect(methodsChanged) 
select new { m, methodsChangedCalled }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods indirectly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSetEx()

// 'depth' represents a code metric defined on methods using
// directly or indirectly any method where code was changed.
let depth = JustMyCode.Methods.DepthOfIsUsingAny(methodsChanged) 

from m in depth.DefinitionDomain where
  !m.CodeWasChanged() && 
  !m.WasAdded()

let methodsChangedDirectlyUsed = m.MethodsCalled.Intersect(methodsChanged) 
let depthOfUsingMethodsChanged = depth[m]
orderby depthOfUsingMethodsChanged 

select new { m, depthOfUsingMethodsChanged, methodsChangedDirectlyUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New fields</Name>
from f in Application.Fields where 
 !f.ParentType.WasAdded() &&
  f.WasAdded()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields removed</Name>
from f in codeBase.OlderVersion().Application.Fields where 
 !f.ParentType.WasRemoved() &&
  f.WasRemoved()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party types that were not used and that are now used</Name>
from t in ThirdParty.Types where t.IsUsedRecently()
select new { t, t.Methods, t.Fields } 
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party types that were used and that are not used anymore</Name>
from t in codeBase.OlderVersion().Types where t.IsNotUsedAnymore()
select new { t, t.Methods, t.Fields }  
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were not used and that are now used</Name>
from m in ThirdParty.Methods where 
  m.IsUsedRecently() &&
 !m.ParentType.IsUsedRecently()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were used and that are not used anymore</Name>
from m in codeBase.OlderVersion().Methods where 
  m.IsNotUsedAnymore() &&
 !m.ParentType.IsNotUsedAnymore()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were not used and that are now used</Name>
from f in ThirdParty.Fields where 
  f.IsUsedRecently() &&
 !f.ParentType.IsUsedRecently()
select f]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were used and that are not used anymore</Name>
from f in codeBase.OlderVersion().Fields where 
  f.IsNotUsedAnymore() &&
 !f.ParentType.IsNotUsedAnymore()
select f
]]></Query>
    </Group>
    <Group Name="Code Coverage" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Code should be tested</Name>
warnif count > 0

// This lambda infers a factor in the range [0,1] from a sequence of distinct types used,
// based on how many of these types are actually concrete (i.e are not interfaces or enumeration).
// Primitive types (int, bool...) are eliminated from the sequence of types used 
// by filtering types declared in the namespace System.
let abstractionUsageFactorFormula = new Func<IEnumerable<IType>,double>(typesUsed => 
            typesUsed.Count(t => t.ParentNamespace.Name != "System" && !t.IsInterface && !t.IsEnumeration) 
     / (1 + typesUsed.Count(t => t.ParentNamespace.Name != "System")))


from method in Application.Methods
  where !method.IsExcludedFromCoverage && method.NbLinesOfCode >= 0 && method.PercentageCoverage < 100 

  // Factor in case method is partially covered
  let uncoverageFactor = ((100 - method.PercentageCoverage) / 100).Value

  // Complexity factor
  let complexityFactor = method.CyclomaticComplexity.Linear(0, 0.1,    10, 1).Value

  // Not my code is often generated code and is in general easier to get tested since test can be generated as well.
  let justMyCodeFactor = (JustMyCode.Contains(method) ? 1 : 0.4)

  // abstractionUsageFactor reflects the fact that code that relies on interfaces
  // is easier to test that code that relies on concrete classes.
  let abstractionUsageFactor = 0.7 + 0.3 *abstractionUsageFactorFormula(method.MembersUsed.Select(m => m.ParentType).Distinct())

  // The usageFactor depends on the method 'rank' that is a value
  // indicating if the method is often used or not
  let usageFactor = (method.Rank / (method.Rank + 4)).Value

  // It is more complicated to write tests for non publicly visible methods
  let visibilityFactor = method.Visibility.EqualsAny(Visibility.Public, Visibility.Internal) ? 1 : 
                         method.Visibility != Visibility.Private ? 1.1 : 1.2
  
  // Is is more complicated to write tests for methods that read mutable static fields 
  // whose changing state is shared across tests executions.
  let staticFieldUsageFactor = method.ReadsMutableTypeState ? 1.3 : 1.0


  // Both "effort to write tests" and "annual cost to not test" for a method
  // is determined by several factors in the range [0,1] that multiplies the effortToDevelop
  let effortToDevelopInMinutes = method.EffortToDevelop().Value.TotalMinutes

  let effortToWriteTests = Math.Max(2, // Minimum 2 minutes per method not tested
        effortToDevelopInMinutes * 
        uncoverageFactor * 
        complexityFactor * 
        justMyCodeFactor * 
        abstractionUsageFactor * 
        visibilityFactor *
        staticFieldUsageFactor).ToMinutes().ToDebt()

  let annualCostToNotFix = Math.Max(2, // Minimum 2 minutes per method not tested
        effortToDevelopInMinutes * 
        usageFactor *
        uncoverageFactor * 
        justMyCodeFactor).ToMinutes().ToAnnualInterest()
 
  orderby annualCostToNotFix.Value descending

select new { 
  method, 
  method.PercentageCoverage,
  method.NbLinesOfCode,
  method.NbLinesOfCodeNotCovered,
  method.CyclomaticComplexity,
  Debt = effortToWriteTests, 
  AnnualInterest = annualCostToNotFix,

  // BreakingPoint = effortToWriteTests.BreakingPoint(annualCostToNotFix),

  // Uncomment the line below to tinker with various factors
  //  uncoverageFactor, complexityFactor , justMyCodeFactor , abstractionUsageFactor, visibilityFactor, staticFieldUsageFactor 
}


//<Description>
// This rule lists methods not covered at all by test
// or partially covered by tests.
//
// For each match, the rules estimates the **technical debt**, i.e
// the effort to write unit and integration tests for the method.
// The estimation is based on the effort to develop the code element
// multiplied by factors in the range ]0,1.3] based on 
//
// • the method code size and complexity
//
// • the actual percentage coverage
//
// • the abstracness of types used, because relying on classes instead of 
// interfaces makes the code more difficult to test
//
// • the method visibility because testing private or protected
// methods is more difficult than testing public and internal ones
//
// • the fields used by the method, because is is more complicated to 
// write tests for methods that read mutable static fields whose changing 
// state is shared across tests executions.
//
// • whether the method is considered *JustMyCode* or not because *NotMyCode*
// is often generated easier to get tested since tests can be generated as well.
//
// This rule is necessarily a large source of technical debt, since
// the code left untested is by definition part of the technical debt.
//
// This rule also estimates the **annual interest**, i.e the annual cost 
// to let the code uncovered, based on the effort to develop the 
// code element, multiplied by factors based on usage of the code element.
//</Description>

//<HowToFix>
// Write unit tests to test and cover the methods and their parent classes
// matched by this rule.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Methods should be tested</Name>
warnif count > 0
from m in Application.Methods where
  m.NbLinesOfCode > 0 &&
  m.PercentageCoverage < 30 && 
  m.WasAdded() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { 
   m, 
   m.PercentageCoverage, 
   m.NbLinesOfCode, 
   m.NbLinesOfCodeNotCovered,

   // Simplistic Debt estimation, because the effort to write tests for a method not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = m.NbLinesOfCodeNotCovered.Linear(1,2, 10,10).ToMinutes().ToDebt(),

   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets added,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//
// Issues of this rule have a **High** severity because they reflect
// an actual trend to not care about writing tests on refactored code.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes added.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods refactored should be tested</Name>
warnif count > 0
from m in Application.Methods where 
  m.PercentageCoverage < 30 && 
  m.CodeWasChanged() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new {
   m, 
   m.PercentageCoverage,
   m.NbLinesOfCode, 
   m.NbLinesOfCodeNotCovered,

   // Simplistic Debt estimation, because the effort to write tests for a method not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = m.NbLinesOfCodeNotCovered.Linear(1,2, 10,10).ToMinutes().ToDebt(),

   Severity = Severity.High
}  

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets refactored,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//
// Issues of this rule have a **High** severity because they reflect
// an actual trend to not care about writing tests on refactored code.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes refactored.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types almost 100% tested should be 100% tested</Name>
warnif count > 0
from t in Application.Types where 
  t.PercentageCoverage >= 95 && 
  t.PercentageCoverage <= 99 &&
 !t.IsGeneratedByCompiler

  let methodsCulprit = t.Methods.Where(m => m.PercentageCoverage < 100)

  orderby t.NbLinesOfCode descending , 
           t.NbLinesOfCodeNotCovered ,
           t.PercentageCoverage
select new { 
   t, 
   t.PercentageCoverage,
   t.NbLinesOfCode, 
   t.NbLinesOfCodeNotCovered, 
   methodsCulprit,

   // Simplistic Debt estimation, because the effort to write tests for a type not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = t.NbLinesOfCodeNotCovered.Linear(1,2, 20,20).ToMinutes().ToDebt(),

   Severity = Severity.High
} 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// Issues of this rule have a **High** severity because as explained,
// such situation is *bug-prone*.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces almost 100% tested should be 100% tested</Name>
warnif count > 0
from n in Application.Namespaces where 
  n.PercentageCoverage >= 95 && 
  n.PercentageCoverage <= 99 

  let methodsCulprit = n.ChildMethods.Where(m => m.PercentageCoverage < 100)

  orderby n.NbLinesOfCode descending , 
           n.NbLinesOfCodeNotCovered ,
           n.PercentageCoverage
select new { 
   n, 
   n.PercentageCoverage, 
   n.NbLinesOfCode, 
   n.NbLinesOfCodeNotCovered, 
   methodsCulprit,

   // Simplistic Debt estimation, because the effort to write tests for a type not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = n.NbLinesOfCodeNotCovered.Linear(1,2, 50,60).ToMinutes().ToDebt(),

   Severity = Severity.High
} 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of 
// one or several classes in a namespace
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// Issues of this rule have a **High** severity because as explained,
// such situation is *bug-prone*.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet in the namespace.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that used to be 100% covered by tests should still be 100% covered</Name>
        
warnif count > 0
from t in JustMyCode.Types where 
   t.IsPresentInBothBuilds() &&
   t.OlderVersion().PercentageCoverage == 100 &&
   t.PercentageCoverage < 100

from m in t .MethodsAndContructors where 
  m.NbLinesOfCode> 0 && 
  m.PercentageCoverage < 100 &&
 !m.IsExcludedFromCoverage

select new {
   m, 
   m.PercentageCoverage, 

   // Simplistic Debt estimation, because the effort to write tests for a method not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = t.NbLinesOfCodeNotCovered.Linear(1,2, 10,10).ToMinutes().ToDebt(),

   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering 10% of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, typically teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the 10% remaining code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// In this context, this rule warns when a type fully covered by tests is now only partially covered.
//
// Issues of this rule have a **High** severity because often,
// a type that used to be 100% and is not covered anymore 
// is a bug-prone situation that should be carefully handled.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered anymore.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods should have a low C.R.A.P score</Name>

warnif count > 0
from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10 && m.CoverageDataAvailable

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (double)(CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30
orderby CRAP descending, m.NbLinesOfCode descending
select new { 
   m, 
   CRAP, 
   CC, 
   m.PercentageCoverage, m.NbLinesOfCode,

   // CRAP score equals 30   => 10 minutes debt
   // CRAP score equals 3000 => 3 hours to write tests
   Debt = CRAP.Linear(30,10,  3000, 3*60).ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// So far this rule is disabled because other code coverage rules 
// assess properly code coverage issues.
//
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly both complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without introducing any regression bug.
//
// The higher the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// higher than 30, out of CRAP territory.
//
// Notice that this rule doesn't match too short method
// with less than 10 lines of code.
//</Description>

//<HowToFix>
// In such situation, it is recommended to both refactor the complex method logic
// into several smaller and less complex methods 
// (that might belong to some new types especially created),
// and also write unit-tests to full cover the refactored logic. 
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="Modernize C++ Code (You have to enable the clang-tidy plugin to have the results)" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use auto specifier</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-auto"
select new { issue,issue.FilePath,Line=issue.BeginLine }
//This query search for places to use the auto type specifier 
//for variable declarations to improve code readability and maintainability.
//For more details you can refer to http://clang.llvm.org/extra/UseAutoTransform.html      

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 

         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use nullptr</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-nullptr"
select new { issue,issue.FilePath,Line=issue.BeginLine }
//This query search for the null pointer constants (eg. NULL, 0) 
//to replace with the new C++11 nullptr keyword.
//For more details you can refer to http://clang.llvm.org/extra/UseNullptrTransform.html      

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 

       ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize loops</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-loop-convert"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query searh for loops like for(...; ...; ...)  
//to use the new range-based loops in C++11. 
//For more details you can refer to http://clang.llvm.org/extra/LoopConvertTransform.html
       
//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 
         
         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use unique_ptr instead of auto_ptr</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-replace-auto-ptr"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query searh for the uses of the deprecated class std::auto_ptr
//to replace by std::unique_ptr . 
//For more details you can refer to http://clang.llvm.org/extra/ReplaceAutoPtrTransform.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 
         
         
         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use override keyword</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-override"
select new { issue,issue.FilePath,Line=issue.BeginLine }
//This query search for places where you can add the override specifier 
//to member functions that override a virtual function
//in a base class and that don’t already have the specifier
//For more details you can refer to http://clang.llvm.org/extra/AddOverrideTransform.html   

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 
             
         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Pass By Value</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-pass-by-value"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query search places where you can use the pass-by-value idiom.
//For more details you can refer to http://clang.llvm.org/extra/PassByValueTransform.html      

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid Bind</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-avoid-bind"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query search places where you  use std::bind.
//std::bind can be hard to read and can result in larger object files and binaries due to type information that will not be produced by equivalent lambdas.
//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-avoid-bind.html    

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize deprecated headers</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-deprecated-headers"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//Some headers from C library were deprecated in C++ and are no longer welcome in C++ codebases. Some have no effect in C++.
//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-deprecated-headers.html   

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize make_shared</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-make-shared"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This check finds the creation of std::shared_ptr objects
//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-make-shared.html   

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize make_unique</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-make-unique"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This check finds the creation of std::unique_ptr objects
//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-make-unique.html   

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize raw string literal</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-raw-string-literal"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This check finds string literals containing escaped characters.
//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-raw-string-literal.html  

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize redundant void arg</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-redundant-void-arg"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This check finds redundant void argument lists.
//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-redundant-void-arg.html 

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize random shuffle</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-replace-random-shuffle"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This check will find occurrences of std::random_shuffle.
//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-replace-random-shuffle.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize return braced init list</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-return-braced-init-list"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This check will find occurrences of std::random_shuffle.
//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-return-braced-init-list.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize shrink-to-fit</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-shrink-to-fit"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-shrink-to-fit.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize unary static-assert</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-unary-static-assert"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-unary-static-assert.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize use bool literals</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-bool-literals"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-use-bool-literals.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize use default member init</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-default-member-init"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-use-default-member-init.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize use emplace</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-emplace"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-use-emplace.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize use equals default</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-equals-default"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-use-equals-default.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize use equals delete</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-equals-delete"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-use-equals-delete.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize use noexcept</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-noexcept"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-use-noexcept.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize use transparent functors</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-transparent-functors"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-use-transparent-functors.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize use using</Name>
 from issue in ImportedIssues where issue.ToolName=="Clang-Tidy" 
&& issue.Type=="modernize-use-using"
select new { issue,issue.FilePath,Line=issue.BeginLine }


//For more details you can refer to http://clang.llvm.org/extra/clang-tidy/checks/modernize-use-using.html

//N.B.: The Clang-Tidy plugin must be enabled to have result. 
//You can enable it from "Project properties"=> Plugins=>Enable Clang-Tidy Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results.              
     ]]></Query>
    </Group>
    <Group Name="Naming Conventions" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Instance fields should be prefixed with a 'm_'</Name>
warnif count > 0 (from f in Fields where 
  !f.NameLike (@"^m_") && 
  !f.IsStatic  
  // Don't hesitate to customize the regex of NameLike to your preference. 
 && !f.IsGlobal && !f.IsEnumValue && !f.IsThirdParty 
select new { f }).Take(10)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Static fields should be prefixed with a 's_'</Name>
   warnif count > 0 (from f in Fields where 
  !f.NameLike (@"^s_") && 
  f.IsStatic && !f.IsThirdParty 
  select new { f }).Take(10)  
  // Don't hesitate to customize the regex of NameLike to your preference.


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Exception class name should be suffixed with 'Exception'</Name>
warnif count > 0 (from t in Types where t.IsExceptionClass && !t.NameLike (@"Exception$") && !t.IsThirdParty
select new { t, t.NbLinesOfCode }).Take(10)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types name should begin with an Upper character</Name>
warnif count > 0 (from t in Types where 
 !t.NameLike (@"^[A-Z]")      // The name of a type should begin with an Upper letter.
  && // Except if it is generated by compiler or ...
 !t.IsThirdParty && !t.IsGlobal
select new { t, t.NbLinesOfCode }).Take(10)

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with name too long</Name>
warnif count > 0 from t in Application.Types 
where !t.IsGeneratedByCompiler && !t.IsThirdParty

where t.SimpleName.Length > 35 
select new { t, t.SimpleName }

      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with name too long</Name>
warnif count > 0 from m in Application.Methods where 
 !m.IsGeneratedByCompiler 
  && m.SimpleName.Length > 35 && !m.IsThirdParty

select new { m, m.SimpleName }

// The regex matches methods with name longer 
// than 35 characters.
// Method Name doesn't contain the type and namespace 
// prefix, FullName does.
// The regex computes the method name length from 
// the beginning until the first open parenthesis 
// or first lower than (for generic methods).
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid fields with name too long</Name>
warnif count > 0 from f in Application.Fields where
 !f.IsGeneratedByCompiler &&
  f.Name.Length > 35 && !f.IsThirdParty
select f

// The regex matches fields with name longer 
// than 35 characters.
// Field Name doesn't contain the type and 
// namespace prefix, FullName does.
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid naming types and namespaces with the same identifier</Name>

// Not only this can provoke compiler resolution collision,
// but also, this makes code less maintainable because
// concepts are not concisely identified.

warnif count > 0
let hashsetShortNames = Namespaces.Where(n => n.Name.Length > 0).Select(n => n.SimpleName).ToHashSetEx()

from t in JustMyCode.Types
where hashsetShortNames.Contains(t.Name) && !t.IsThirdParty
select new { t, namespaces = Namespaces.Where(n => n.SimpleName == t.Name) }]]></Query>
    </Group>
    <Group Name="CPD Queries" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>All CPD duplications</Name>
from issue in ImportedIssues  where issue.ToolName=="CPD"
select new { issue,issue.FilePath,issue.BeginLine }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most duplicated code lines</Name>
from issue in ImportedIssues  where issue.ToolName=="CPD"
orderby issue.NbDuplicationCopies descending
select new { issue,issue.NbDuplicationCopies }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Big duplications</Name>
from issue in ImportedIssues  where issue.ToolName=="CPD"
orderby issue.NbLinesCopied descending
select new { issue,issue.NbLinesCopied }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Classes containing big duplication</Name>
(from t in Types where t.ImportedIssues.Where(i=>i.ToolName=="CPD" && i.NbLinesCopied>100).Count()>0
orderby t.ImportedIssues.Count() descending
select new { t }).Take(100)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Classes containing Many duplications</Name>
(from t in Types where t.ImportedIssues.Where(i=>i.ToolName=="CPD" && i.NbDuplicationCopies>10).Count()>0
orderby t.ImportedIssues.Count() descending
select new { t }).Take(100)]]></Query>
    </Group>
    <Group Name="Hot Spots" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types Hot Spots</Name>
from t in JustMyCode.Types
where t.AllDebt() > Debt.Zero && 
      t.AllAnnualInterest() > AnnualInterest.Zero
orderby t.AllDebt().Value.TotalMinutes descending
select new { t, 
   Debt = t.AllDebt(),
   Issues = t.AllIssues(), // AllIssues = {types issues} union {members issues}
   AnnualInterest = t.AllAnnualInterest(),
   BreakingPoint = t.AllBreakingPoint(),
   t.NbLinesOfCode,
   // t.PercentageCoverage,  to uncomment if coverage data is imported
   DebtRating = t.DebtRating(), 
   DebtRatio = t.DebtRatio() 
}

//<Description>
// This query lists **types with most Debt**,
// or in other words, types with issues that would need 
// the largest effort to get fixed.
//
// Both issues on the type and its members are
// taken account.
//
// Since untested code often generates a lot of 
// Debt, the type size and percentage coverage is shown
// (just uncomment *t.PercentageCoverage* in the query 
// source code once you've imported the coverage data).
//
// The *Debt Rating* and *Debt Ratio* are also shown
// for informational purpose.
//
// --
//
// The amount of *Debt* is not a measure to prioritize
// the effort to fix issues, it is an estimation of how far 
// the team is from clean code that abides by the rules set.
//
// For each issue the *Annual Interest* estimates the annual 
// cost to leave the issues unfixed. The *Severity* of an issue
// is estimated through thresholds from the *Annual Interest*.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issue unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issue. The **Breaking Point is the right metric
// to prioritize issues fix**.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types to Fix Priority</Name>
from t in JustMyCode.Types
where t.AllBreakingPoint() > TimeSpan.Zero &&
      t.AllDebt().Value > 30.ToMinutes()
orderby t.AllBreakingPoint().TotalMinutes ascending
select new { t, 
   BreakingPoint = t.AllBreakingPoint(),
   Debt = t.AllDebt(),
   AnnualInterest = t.AllAnnualInterest(),
   Issues = t.AllIssues(),
   t.NbLinesOfCode,
   // t.PercentageCoverage,  to uncomment if coverage data is imported
   DebtRating = t.DebtRating(), 
   DebtRatio = t.DebtRatio() 
}

//<Description>
// This query lists types per increasing
// **Debt Breaking Point**.
//
// For each issue the *Debt* estimates the
// effort to fix the issue, and the *Annual Interest*
// estimates the annual cost to leave the issue unfixed.
// The *Severity* of an issue is estimated through 
// thresholds from the *Annual Interest* of the issue.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issue unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issues.
//
// Often new and refactored types since baseline will be 
// listed first, because issues on these types get a 
// higher *Annual Interest* because it is important to
// focus first on new issues.
// 
//
// --
//
// Both issues on the type and its members are
// taken account.
//
// Only types with at least 30 minutes of Debt are listed
// to avoid parasiting the list with the numerous
// types with small *Debt*, on which the *Breaking Point*
// value makes less sense. 
//
// The *Annual Interest* estimates the cost per year
// in man-days to leave these issues unfixed.
//
// Since untested code often generates a lot of 
// Debt, the type size and percentage coverage is shown
// (just uncomment *t.PercentageCoverage* in the query 
// source code once you've imported the coverage data).
//
// The *Debt Rating* and *Debt Ratio* are also shown
// for informational purpose.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Issues to Fix Priority</Name>
from i in Issues
// Don't show first issues with BreakingPoint equals to zero.
orderby i.BreakingPoint != TimeSpan.Zero ? i.BreakingPoint : TimeSpan.MaxValue
select new { i, 
   Debt = i.Debt,
   AnnualInterest = i.AnnualInterest,
   BreakingPoint = i.BreakingPoint,
   CodeElement = i.CodeElement
}

//<Description>
// This query lists issues per increasing
// **Debt Breaking Point**.
//
// Double-click an issue to edit its rule and
// select the issue in the rule result. This way
// you can view all information concerning the issue.
//
// For each issue the *Debt* estimates the
// effort to fix the issue, and the *Annual Interest*
// estimates the annual cost to leave the issue unfixed.
// The *Severity* of an issue is estimated through 
// thresholds from the *Annual Interest* of the issue.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issue unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issue.
//
// Often issues on new and refactored code elements since 
// baseline will be listed first, because such issues get a 
// higher *Annual Interest* because it is important to
// focus first on new issues on recent code.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Debt and Issues per Rule</Name>
from r in Rules
where r.IsViolated()
orderby r.Debt().Value descending
select new { 
   r, 
   Issues = r.Issues(), 
   Debt = r.Debt(), 
   AnnualInterest = r.AnnualInterest(), 
   BreakingPoint = r.BreakingPoint(),
   Category = r.Category
}

//<Description>
// This query lists violated rules with most *Debt* first.
//
// A rule violated has issues. For each issue the *Debt* 
// estimates the effort to fix the issue.
//
// --
//
// The amount of *Debt* is not a measure to prioritize
// the effort to fix issues, it is an estimation of how far 
// the team is from clean code that abides by the rules set.
//
// For each issue the *Annual Interest* estimates the annual 
// cost to leave the issues unfixed. The *Severity* of an issue
// is estimated through thresholds from the *Annual Interest*.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issue unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issue. The **Breaking Point is the right metric
// to prioritize issues fix**.
//
// --
//
// Notice that rules can be grouped in *Rule Category*. This
// way you'll see categories that generate most *Debt*.
//
// Typically the rules that generate most *Debt* are the 
// ones related to *Code Coverage by Tests*, *Architecture*
// and *Code Smells*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Debt and Issues per Rule</Name>
from r in Rules
where r.IsViolated() && r.IssuesAdded().Count() > 0
orderby r.DebtDiff().Value descending
select new { 
   r, 
   IssuesAdded = r.IssuesAdded(),
   IssuesFixed = r.IssuesFixed(),
   Issues = r.Issues(), 
   Debt = r.Debt(), 
   DebtDiff = r.DebtDiff(),
   Category = r.Category
}

//<Description>
// This query lists violated rules that have new issues
// since baseline, with most **new Debt** first.
//
// A rule violated has issues. For each issue the *Debt* 
// estimates the effort to fix the issue.
//
// --
//
// New issues since the baseline are consequence of recent code 
// refactoring sessions. They represent good opportunities
// of fix because the code recently refactored is fresh in 
// the developers mind, which means fixing now costs less
// than fixing later.
//
// Fixing issues on recently touched code is also a good way 
// to foster practices that will lead to higher code quality 
// and maintainability, including writing unit-tests
// and avoiding unnecessary complex code.
//
// --
//
// Notice that rules can be grouped in *Rule Category*. This
// way you'll see categories that generate most *Debt*.
//
// Typically the rules that generate most *Debt* are the 
// ones related to *Code Coverage by Tests*, *Architecture*
// and *Code Smells*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Debt and Issues per Code Element</Name>
from elem in CodeElements
where elem.HasIssue()
orderby elem.Debt().Value descending
select new { 
   elem, 
   Issues = elem.Issues(), 
   Debt = elem.Debt(), 
   AnnualInterest = elem.AnnualInterest(), 
   BreakingPoint = elem.BreakingPoint()
}

//<Description>
// This query lists code elements that have issues, 
// with most *Debt* first.
//
// For each code element the *Debt* estimates 
// the effort to fix the element issues.
//
// The amount of *Debt* is not a measure to prioritize
// the effort to fix issues, it is an estimation of how far 
// the team is from clean code that abides by the rules set.
//
// For each element the *Annual Interest* estimates the annual 
// cost to leave the elements issues unfixed. The *Severity* of an 
// issue is estimated through thresholds from the *Annual Interest*
// of the issue.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issues unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issue. The **Breaking Point is the right metric
// to prioritize issues fix**.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Debt and Issues per Code Element</Name>
from elem in CodeElements
where elem.HasIssue() && elem.IssuesAdded().Count() > 0
orderby elem.DebtDiff().Value descending
select new { 
   elem, 
   IssuesAdded = elem.IssuesAdded(),
   IssuesFixed = elem.IssuesFixed(),
   Issues = elem.Issues(), 
   Debt = elem.Debt(), 
   DebtDiff = elem.DebtDiff()
}
    //<Description>
// This query lists code elements that have new issues
// since baseline, with most **new Debt** first.
//
// For each code element the *Debt* estimates 
// the effort to fix the element issues.
//
// New issues since the baseline are consequence of recent code 
// refactoring sessions. They represent good opportunities
// of fix because the code recently refactored is fresh in 
// the developers mind, which means fixing now costs less
// than fixing later.
//
// Fixing issues on recently touched code is also a good way 
// to foster practices that will lead to higher code quality 
// and maintainability, including writing unit-tests
// and avoiding unnecessary complex code.
//</Description>
]]></Query>
    </Group>
    <Group Name="Statistics" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (Rank)</Name>
(from t in Application.Types orderby t.Rank descending
 select new { t, t.Rank }).Take(50)

// TypeRank values are computed by applying 
// the Google PageRank  algorithm on the 
// graph of types' dependencies. Types with 
// high Rank are the most used ones.
// See the definition of the TypeRank metric here: 
// http://www.cppdepend.com/Metrics.aspx#TypeRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (Rank)</Name>
(from m in Application.Methods orderby m.Rank descending
 select new { m, m.Rank }).Take(50)

// MethodRank values are computed by applying 
// the Google PageRank  algorithm on the graph of 
// methods' dependencies. Methods with high Rank 
// are the most used ones. See the definition of 
// the MethodRank metric here:
// http://www.cppdepend.com/Metrics.aspx#MethodRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used namespaces (#NamespacesUsingMe )</Name>
(from n in Namespaces orderby n.NbNamespacesUsingMe descending
 select new { n, n.NamespacesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (#TypesUsingMe )</Name>
(from t in Types orderby t.NbTypesUsingMe descending
 select new { t, t.TypesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (#MethodsCallingMe )</Name>
(from m in Methods orderby m.NbMethodsCallingMe descending
 select new { m, m.MethodsCallingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces that use many other namespaces (#NamespacesUsed )</Name>
(from n in Application.Namespaces orderby n.NbNamespacesUsed descending
 select new { n, n.NamespacesUsed }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that use many other types (#TypesUsed )</Name>
(from t in Application.Types orderby t.NbTypesUsed descending
 select new { t, t.TypesUsed }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that use many other methods (#MethodsCalled )</Name>
(from m in Application.Methods orderby m.NbMethodsCalled descending
 select new { m, m.MethodsCalled }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level Projects (Level)</Name>
from a in Application.Projects orderby a.Level descending
select new { a, a.Level }

// Classify Projects by their Level values.
// See the definition of the projectLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level namespaces (Level)</Name>
from n in Application.Namespaces orderby n.Level descending
select new { n, n.Level }

// Classify namespaces by their Level values.
// See the definition of the NamespaceLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level types (Level)</Name>
from t in Application.Types orderby t.Level descending
select new { t, t.Level }

// Classify types by their Level values.
// See the definition of the TypeLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level methods (Level)</Name>
from m in Application.Methods orderby m.Level descending
select new { m, m.Level }

// Classify methods by their Level values.
// See the definition of the MethodLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
    </Group>
    <Group Name="Samples of Custom rules" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is not using the project P2</Name>
warnif count > 0 from a in Application.Projects where 
  a.IsUsing ("P2".AllowNoMatch().MatchProject()) &&
  (a.Name == @"P1")
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is only using the Projects P2 or P3</Name>
warnif count > 0 from a in Application.Projects where 
  ( !a.IsUsing ("P2".AllowNoMatch().MatchProject()) ||
    !a.IsUsing ("P3".AllowNoMatch().MatchProject()) ||
    a.ProjectsUsed.Count() != 2) // Must not be used more than 2 Projects 
&& 
  (a.Name == @"P1")
select new { a, a.ProjectsUsed }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that only 3 Projects are using Project P</Name>
warnif count != 3 from a in Application.Projects where 
  a.IsUsing ("P".AllowNoMatch().MatchProject())
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)</Name>
warnif count > 0 from m in Application.Methods where 
   m.IsUsing ("Foo.Fct1()".AllowNoMatch()) &&
  !m.IsUsing ("Foo.Fct2(Int32)".AllowNoMatch())
select m
]]></Query>
      <Group Name="Custom Naming Conventions" Active="False" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that derive from Foo, has a name that ends up with Foo</Name>
warnif count > 0 from t in Application.Types where 
   t.DeriveFrom ("Foo".AllowNoMatch().MatchType()) &&
  !t.NameLike (@"Foo$")
select new { t, t.NbLinesOfCode }
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all namespaces begins with CompanyName.ProductName</Name>
warnif count > 0 from n in Application.Namespaces where 
  !n.NameLike (@"^CompanyName.ProductName")
select new { n, n.NbLinesOfCode } ]]></Query>
      </Group>
    </Group>
    <Group Name="Trend Metrics" Active="True" ShownInReport="False">
      <Group Name="Issues" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# New Issues since Baseline" Unit="issues"/>
from issue in Issues 
where issue.WasAdded()
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues Fixed since Baseline" Unit="issues"/>
from issue in Issues 
where issue.WasFixed()
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues Worsened since Baseline" Unit="issues"/>
from issue in Issues 
where !issue.WasAdded() && 
      (issue.DebtDiff() > Debt.Zero || issue.AnnualInterestDiff() > AnnualInterest.Zero)
select new { 
   issue, 
   issue.Debt, debtDiff = issue.DebtDiff(), 
   issue.AnnualInterest, annualInterestDiff = issue.AnnualInterestDiff(),
   issue.Severity 
}

//<Description>
// An issue is considered worsened if its *debt* increased since the baseline.
//
// Debt documentation: https://www.ndepend.com/docs/technical-debt#Debt
//</Description>
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity Blocker" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Blocker
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity Critical" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Critical
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed during the next iterations. 
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity High" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.High
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with a severity level **High** should be fixed quickly, but can wait until the next scheduled interval.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity Medium" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Medium
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with a severity level **Medium** is a warning that if not fixed, won't have a significant impact on development.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues with severity Low" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Low
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// The severity level **Low** is used by issues that have a zero, or close to zero, 
// value for **Annual Interest**.
//
// Issues with a **Low** or **Medium** severity level represents small improvements, 
// ways to make the code looks more elegant.
//
// The **Broken Window Theory** https://en.wikipedia.org/wiki/Broken_windows_theory states that:
//
// *"Consider a building with a few broken windows. 
// If the windows are not repaired, the tendency is for vandals to break a few more windows. 
// Eventually, they may even break into the building, and if it's unoccupied, perhaps become 
// squatters or light fires inside."*
//

// Issues with a *Low* or *Medium* severity level represents the *broken windows* of a code base.
// If they are not fixed, the tendency is for developers to not care for living 
// in an elegant code, which will result in extra-maintenance-cost in the long term.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Blocker/Critical/High Issues" Unit="issues"/>
from issue in Issues 
where issue.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High)
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// The number of issues with a severity Blocker, Critical or High.
//
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed during the next iterations. 
//
// An issue with a severity level **High** should be fixed quickly, but can wait until the next scheduled interval.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues" Unit="issues"/>
from issue in Issues 
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// The number of issues no matter the issue severity.
//</Description>]]></Query>
      </Group>
      <Group Name="Rules" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Rules" Unit="rules"/>
from rule in Rules
select new { 
   rule, 
   issues = rule.Issues(), 
   debt = rule.Debt(), 
   annualInterest = rule.AnnualInterest(),
   maxSeverity = rule.IsViolated() && rule.Issues().Any() ? 
                 (Severity?)rule.Issues().Max(i => i.Severity) : null
}

//<Description>
// This trend metric counts the number of active rules.
// This count includes violated and not violated rules.
// This count includes critical and non critical rules.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Rules Violated" Unit="rules"/>
from rule in Rules
where rule.IsViolated()
select new { 
   rule, 
   issues = rule.Issues(), 
   debt = rule.Debt(), 
   annualInterest = rule.AnnualInterest(),
   maxSeverity = rule.IsViolated() && rule.Issues().Any() ? 
                 (Severity?)rule.Issues().Max(i => i.Severity) : null
}

//<Description>
// This trend metric counts the number of active rules that are violated.
// This count includes critical and non critical rules.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Critical Rules Violated" Unit="rules"/>
from rule in Rules
where rule.IsViolated() && rule.IsCritical
select new { 
   rule, 
   issues = rule.Issues(), 
   debt = rule.Debt(), 
   annualInterest = rule.AnnualInterest(),
   maxSeverity = rule.IsViolated() && rule.Issues().Any() ? 
                 (Severity?)rule.Issues().Max(i => i.Severity) : null
}

//<Description>
// This trend metric counts the number of critical active rules that are violated.
//
// The concept of critical rule is useful to pinpoint certain rules that should not be violated.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      </Group>
      <Group Name="Quality Gates" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Quality Gates" Unit="quality gates"/>
from qualityGate in QualityGates
select new { 
   qualityGate , 
   qualityGate.ValueString,
   qualityGate.Status, 
}

//<Description>
// This trend metric counts the number of active quality gates,
// no matter the gate status (Pass, Warn, Fail).
//
// When no baseline is available, quality gates that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that quality gates that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Quality Gates Warn" Unit="quality gates"/>
from qualityGate in QualityGates
where qualityGate.Warn
select new { 
   qualityGate , 
   qualityGate.ValueString, 
}

//<Description>
// This trend metric counts the number of active quality gates that warns.
//
// When no baseline is available, quality gates that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that quality gates that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Quality Gates Fail" Unit="quality gates"/>
from qualityGate in QualityGates
where qualityGate.Fail
select new { 
   qualityGate , 
   qualityGate.ValueString, 
}

//<Description>
// This trend metric counts the number of active quality gates that fails.
//
// When no baseline is available, quality gates that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that quality gates that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      </Group>
      <Group Name="Debt" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Percentage Debt (Metric)" Unit="%" />
let timeToDev = codeBase.EffortToDevelop()
let debt = Issues.Sum(i => i.Debt)
select 100d * debt.ToManDay() / timeToDev.ToManDay()

// <Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Infer a percentage from:
//
// • the estimated total time to develop the code base
//
// • and the the estimated total time to fix all issues (the Debt).
//
// Estimated total time to develop the code base is inferred from 
// # lines of code of the code base and from the 
// *Estimated number of man-day to develop 1000 logicial lines of code*
// setting found in NDepend Project Properties > Issue and Debt.
//
// Debt documentation: https://www.ndepend.com/docs/technical-debt#Debt
// </Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Debt (Metric)" Unit="man-days" />
Issues.Sum(i => i.Debt).ToManDay()

//<Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Debt documentation: https://www.ndepend.com/docs/technical-debt#Debt
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="New Debt since Baseline (Metric)" Unit="man-days" />
let debt = Issues.Sum(i => i.Debt)
let debtInBaseline = IssuesInBaseline.Sum(i => i.Debt)
select (debt - debtInBaseline).ToManDay()

//<Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Debt added (or fixed if negative) since baseline.
//
// Debt documentation: https://www.ndepend.com/docs/technical-debt#Debt
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Annual Interest (Metric)" Unit="man-days" />
Issues.Sum(i => i.AnnualInterest).ToManDay()

//<Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Annual Interest documentation: https://www.ndepend.com/docs/technical-debt#AnnualInterest
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="New Annual Interest since Baseline (Metric)" Unit="man-days" />
let ai = Issues.Sum(i => i.AnnualInterest)
let aiInBaseline = IssuesInBaseline.Sum(i => i.AnnualInterest)
select (ai - aiInBaseline).ToManDay()

//<Description>
// This Trend Metric name is suffixed with (Metric)
// to avoid query name collision with the Quality Gate with same name.
//
// Annual Interest added (or fixed if negative) since baseline.
//
// Annual Interest documentation: https://www.ndepend.com/docs/technical-debt#AnnualInterest
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Breaking Point" Unit="years"/>
(Issues.Sum(i =>i.Debt).BreakingPoint(Issues.Sum(i =>i.AnnualInterest))).TotalYears()

// <Description>
// The **breaking point** of a set of issues is the **debt** divided by the **annual interest**.
//
// The *debt* is the estimated cost-to-fix the issues.
//
// The *annual interest* is the estimated cost-to-**not**-fix the issues, per year.
//
// Hence the *breaking point* is the point in time from now, when not fixing the issues cost as much as fixing the issue.
//
// Breaking Point documentation: https://www.ndepend.com/docs/technical-debt#BreakingPoint
// </Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Breaking Point of Blocker / Critical / High Issues" Unit="years"/>
let issues = Issues.Where(i => i.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High))
select (issues.Sum(i =>i.Debt).BreakingPoint(issues.Sum(i =>i.AnnualInterest))).TotalYears()

// <Description>
// The **breaking point** of a set of issues is the **debt** divided by the **annual interest**.
//
// The *debt* is the estimated cost-to-fix the issues.
//
// The *annual interest* is the estimated cost-to-**not**-fix the issues, per year.
//
// Hence the *breaking point* is the point in time from now, when not fixing the issues cost as much as fixing the issue.
//
// Breaking Point documentation: https://www.ndepend.com/docs/technical-debt#BreakingPoint
// </Description>]]></Query>
      </Group>
      <Group Name="Code Size" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code" Unit="LoC" />  
Application.Projects.Sum(a => a.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (JustMyCode)" Unit="LoC" />
JustMyCode.Methods.Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (NotMyCode)" Unit="LoC" />
Application.Methods.Where(m => !JustMyCode.Contains(m))
                   .Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Added since the Baseline" Unit="LoC" />  
( from a in Application.Projects
  let nbLocAdded = a.IsPresentInBothBuilds() ? 
                   a.NbLinesOfCode - (int)a.OlderVersion().NbLinesOfCode :
                   a.NbLinesOfCode
  select nbLocAdded)
.Sum(loc => loc)

// A value is computed by this Trend Metric query
// only if a Baseline for Comparison is provided.
// See Project Properties > Analysis > Baseline for Comparison
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Source Files" Unit="Source Files" />
Application.Projects.SelectMany(
  a => a.SourceDecls.Select(sd => sd.SourceFile.FilePathString.ToLower()))
.Distinct()
.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Comments" Unit="Lines" />  
Application.Projects.Sum(a => a.NbLinesOfComment)


]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Projects" Unit="Projects" />
Application.Projects.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Namespaces" Unit="Namespaces" />
Application.Namespaces.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Types" Unit="Types" />
Application.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Classes" Unit="Types" />
Application.Types.Count(t => t.IsClass && !t.IsGeneratedByCompiler)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Abstract Classes" Unit="Types" />
Application.Types.Count(t => t.IsClass && t.IsAbstract)

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Interfaces" Unit="Types" />
Application.Types.Count(t => t.IsInterface)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Structures" Unit="Types" />
Application.Types.Count(t => t.IsStructure)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Methods" Unit="Methods" />
Application.Methods.Count(m => !m.IsGeneratedByCompiler)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Abstract Methods" Unit="Methods" />
Application.Methods.Count(m => m.IsAbstract)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Concrete Methods" Unit="Methods" />
Application.Methods.Count(m => !m.IsAbstract && !m.IsGeneratedByCompiler)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Fields" Unit="Fields" />
Application.Fields.Count(f => 
   !f.IsEnumValue && 
   !f.IsGeneratedByCompiler && 
   !f.ParentType.IsEnumeration)

]]></Query>
      </Group>
      <Group Name="Maximum and Average" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Methods (JustMyCode)" Unit="LoC" />
JustMyCode.Methods
          .Max(m => m.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) method with largest # Lines of Code
// JustMyCode.Methods.OrderByDescending(m => m.NbLinesOfCode).Take(1).Select(m => new {m, m.NbLinesOfCode})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode > 0)
                   .Average(m => m.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods with at least 3 Lines of Code" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode >= 3)
                   .Average(m => m.NbLinesOfCode)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Types (JustMyCode)" Unit="LoC" />
JustMyCode.Types
          .Max(t => t.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # Lines of Code
// JustMyCode.Types.OrderByDescending(t => t.NbLinesOfCode).Take(1).Select(t => new {t, t.NbLinesOfCode})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Types" Unit="LoC" />
Application.Types.Where(t => t.NbLinesOfCode > 0)
                 .Average(t => t.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods
          .Max(m => m.CyclomaticComplexity)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m => m.CyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Cyclomatic Complexity for Types" Unit="Paths" />
Application.Types
          .Max(t => t.CyclomaticComplexity)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m => m.CyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods.Where(m => m.NbLinesOfCode> 0)
                   .Average(m => m.CyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Cyclomatic Complexity for Types" Unit="Paths" />
Application.Types.Where(t => t.NbLinesOfCode> 0)
                   .Average(t => t.CyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Nesting Depth for Methods" Unit="Scopes" />
Application.Methods
          .Max(m => m.NestingDepth)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the method with highest NestingDepth.
// Application.Methods.OrderByDescending(m => m.NestingDepth).Take(1).Select(m => new {m, m.NestingDepth})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Nesting Depth for Methods" Unit="Scopes" />
Application.Methods.Average(m => m.NestingDepth)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Types" Unit="Methods" />
Application.Types
           .Max(t => t.NbMethods) 
           .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Types" Unit="Methods" />
Application.Types.Average(t => t.NbMethods)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Interfaces" Unit="Methods" />
Application.Types.Where(t => t.IsInterface)
           .Max(t => t.NbMethods) 
           .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Interfaces" Unit="Methods" />
JustMyCode.Types.Where(t => t.IsInterface)
                .Average(t => t.NbMethods)
]]></Query>
      </Group>
      <Group Name="Coverage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Percentage Code Coverage" Unit="%" />
((float)Application.Projects.Sum(a => a.NbLinesOfCodeCovered) /
        Application.Projects.Sum(a => a.NbLinesOfCode)
 * 100f)
.ToEnumerable().Sum()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Covered" Unit="LoC" />
Application.Projects.Sum(a => a.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Not Covered" Unit="LoC" />
Application.Projects.Sum(a => a.NbLinesOfCodeNotCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Types 100% Covered" Unit="LoC" />
Application.Types.Where(t => t.PercentageCoverage == 100)
           .Sum(t => t.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Methods 100% Covered" Unit="LoC" />
Application.Methods.Where(m => m.PercentageCoverage == 100)
           .Sum(m => m.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Max(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Average(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
      </Group>
      <Group Name="Third-Party Usage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Projects Used" Unit="Projects" />
ThirdParty.Projects.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Namespaces Used" Unit="Namespaces" />
ThirdParty.Namespaces.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Types Used" Unit="Types" />
ThirdParty.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Methods Used" Unit="Methods" />
ThirdParty.Methods.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Fields Used" Unit="Fields" />
ThirdParty.Fields.Count()]]></Query>
      </Group>
    </Group>
    <Group Name="Defining JustMyCode" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard methods with a pattern name</Name>
notmycode from m in Methods where m.SimpleName.StartsWith("pattern to exclude")
select m

//<Description>
//The domain JustMyCode represents a facility of CQLinq to eliminate generated code elements from CQLinq query results.
//For example the following query will only match large methods that are not generated by a tool (like a UI designer):
//from m in JustMyCode.Methods where m.NbLinesOfCode > 30 select m
//The set of generated code elements is defined by CQLinq queries prefixed with the CQLinq keyword notmycode.
//For example the query below matches methods defined in source files whose name ends up with a pattern. These are file generated by some tools:
//notmycode from m in Methods where
//  m.SourceFileDeclAvailable && 
//  m.SourceDecl.SourceFile.FileName.ToLower().EndsWith(".designer.cs")
//  select m
//The CQLinq queries runner executes all notmycode queries before queries relying on JustMyCode, hence the domain JustMyCode is defined once for all. Obviously the CQLinq compiler emits an error if a notmycode query relies on the JustMyCode domain. 
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard types with a pattern name</Name>
notmycode from t in Types where t.Name.StartsWith("pattern to exclude")
select t

//<Description>
//The domain JustMyCode represents a facility of CQLinq to eliminate generated code elements from CQLinq query results.
//For example the following query will only match large types that are not generated by a tool (like a UI designer):
//from m in JustMyCode.Types where t.NbLinesOfCode > 3000 select t
//The set of generated code elements is defined by CQLinq queries prefixed with the CQLinq keyword notmycode.
//For example the query below matches types defined in source files whose name ends up with a pattern. These are file generated by some tools:
//notmycode from t in Types where
//  t.SourceFileDeclAvailable && 
//  t.SourceDecl.SourceFile.FileName.ToLower().EndsWith("pattern to exclude")
//  select m
//The CQLinq queries runner executes all notmycode queries before queries relying on JustMyCode, hence the domain JustMyCode is defined once for all. Obviously the CQLinq compiler emits an error if a notmycode query relies on the JustMyCode domain. 
//</Description>


]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>JustMyCode code elements</Name>
from elem in JustMyCode.CodeElements
select new { 
  elem,
  loc = elem.IsCodeContainer ? elem.AsCodeContainer.NbLinesOfCode : null
}

//<Description>
// This code query enumerates all
// *projects*, *namespaces*, *types*, *methods* and *fields*
// in your application, that are considered as being your code.
//
// This means concretely that the *ICodeBaseView* **JustMyCode**
// only shows these code elements. This code base view is used by 
// many default code rule to avoid being warned on code elements 
// that you don't consider as your code - typically the code 
// elements generated by a tool.
//
// These code elements are the ones that are not matched 
// by any quere prefixed with  **notmycode**.
//</Description>]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>NotMyCode code elements</Name>
from elem in Application.CodeElements.Where(element => !JustMyCode.Contains(element))
select new { 
  elem,
  loc = elem.IsCodeContainer ? elem.AsCodeContainer.NbLinesOfCode : null
}

//<Description>
// This code query enumerates all
// *projects*, *namespaces*, *types*, *methods* and *fields*
// in your application, that are considered as not being your code.
//
// This means concretely that the *ICodeBaseView* **JustMyCode**
// hide these code elements. This code base view is used by 
// many default code rules to avoid being warned on code elements 
// that you don't consider as your code - typically the code 
// elements generated by a tool.
//
// These code elements are the ones matched by queries prefixed with 
// **notmycode**.
//</Description>]]></Query>
    </Group>
  </Queries>
</NDepend>